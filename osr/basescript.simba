(*
BaseScript
==========
BaseScript and it's derivants are template records to be used in scripts.
They also contain template functions and procedures that can be used as is or overriden with
"inherited" to add functionality.
*)

{$DEFINE WL_BASESCRIPT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
(*
type TBaseScript
~~~~~~~~~~~~~~~~
Record that holds common variables for most basic scripts.
The variables that are part of **TBaseScript** are the following:
 - **Name**: String that holds the script name to be displayed in the log and on screen progress report.
 - **Version**: String that holds the script version to be displayed in the log and on screen progress report.
 - **IsSetup**: Boolean that let us know if the our **TBaseScript** already set it's variables up.
 - **TimeRunning**: TStopwatch variable that holds how long our **TBaseScript** has been running.
 - **StatsDebugTick**: Integer variabled used to register the last tick we printed a progress report.
 - **Action**: String variable used to print in Simba output or on screen progress report the current action the script is performing.
 - **PreviousAction**: String variable used to register the previous action. This is used to avoid spamming the logs.
 - **ExtraInfo**: String variable we can use to print extra information in Simba output or in on screen progress report. E.G. current state of variables.
 - **ActionProfit**: Integer that holds information on how much profit (positive or negative) our script makes per action performed.
 - **TotalActions**: Integer used to count how many actions our script has done.
 - **TotalProfit**:  Integer that holds the total profit our script has done.
 - **TimeLimit**: Integer variable to set a time limit for our script in milliseconds before ending the current script.
 - **ActionLimit**: Integer variable to set total action limit before ending the script.
*)
  TBaseScript = record(TSRLBaseRecord)
    Version: String;

    IsSetup: Boolean;

    TimeRunning: TStopwatch;
    StatsDebugTick: UInt64;

    Action: String;
    PreviousAction: String;

    ExtraInfo: String;

    ActionProfit: Int32;
    TotalActions: Int32;
    TotalProfit: Int32;

    TimeLimit: Int64;
    ActionLimit: Int32;
  end;

(*
type TBaseWalkerScript
~~~~~~~~~~~~~~~~
Record that holds common variables for most scripts that use walker.
This record inherits from **TBaseScript** and has all of it's variables too.
The extra variables that are part of **TBaseWalkerScript** are:
 - **RSW**: TRSWalker variable that holds our walker, for more information check the following page: https://ollydev.github.io/SRL-Development/walker.html?highlight=walker
*)
  TBaseWalkerScript = record(TBaseScript)
    RSW: TRSWalker;
  end;

(*
type TBaseBankScript
~~~~~~~~~~~~~~~~
Record that holds common variables for most scripts that use a bank.
This record inherits from **TBaseWalkerScript** and has all of it's variables as well as **TBaseScript's**.
The extra variables that are part of **TBaseBankScript** are:
 - **ScriptBank**: PRSObject pointer that points to our current bank TRSObject, for more info check: https://torwent.github.io/WaspLib/waspobject.html#type-trsobject
 - **ScriptBanker**: PRSNPC pointer that points to our current banker TRSNPC, for more info check: https://torwent.github.io/WaspLib/waspobject.html#type-trsmmdot
 - **BankTab**: Integer variable used to cache the current bank tab that contains items for our script.
 - **ItemLeftAmount**: Integer variable used to cache items left to make/build/whatever to pre-hover the bank.
 - **HoveringBank**: Boolean variable that holds information if we are currently already hovering the bank. This is so we don't try to rehover the bank and don't need to check the uptext if we already are doing it.
 - **BankEmpty**: Boolean variable that that is set to true when we ran out of an item our script needs. This is used so next time we need to fetch the item we check the deposit box instead.
 - **CollectEmpty**: Boolean variable that that is set to true when the collect box is empty. Normally, if this and **BankEmpty** are true the script ends.
 - **CollectTimer**: TCountDown variable used to reset **CollectEmpty** after a couple of minutes.
*)
  TBaseBankScript = record(TBaseWalkerScript)
    ScriptBank:   PRSObject;
    ScriptBanker: PRSNPC;

    BankTab: Int32;

    ItemLeftAmount: Int32;
    HoveringBank: Boolean;
    BankEmpty: Boolean;       //Used to cache if Bank doesn't have more of a certain item.
    CollectEmpty: Boolean;    //Used to cache if CollectBox doesn't have more of a certain item.
    CollectTimer: TCountDown; //Used to reset CollectEmpty after a while.
  end;

var
  TotalConsumableCost: Int32;

procedure TBaseScript.Init(MaxActions: Int32; MaxTime: Int64); //override me to add more stuff.
begin
  DisableDebugging := True;
  Version := ReadFileContents(IncludePath + 'WaspLib\version.txt');

  if MaxActions > -1 then ActionLimit := TotalActions + MaxActions
  else ActionLimit := -1;

  TimeRunning.Start;

  if MaxTime > -1 then TimeLimit := TimeRunning.ElapsedTime + MaxTime
  else TimeLimit := -1;


  WL.Activity.Init(260000);

  if IsSetup then Exit;
  IsSetup := True;

  {$IFDEF SRL_USE_REMOTEINPUT}
  if RemoteInputEnabled then
  begin
    RSClient.RemoteInput.Setup;
    if ProgressReportEnabled then ProgressReport.Setup;
  end;
  {$ENDIF}

  Antiban.Setup;

  //override me to add more stuff.
end;

function TBaseScript.DoAntiban(CheckBreaks: Boolean = True; CheckSleeps: Boolean = True): Boolean;
begin
  Antiban.DismissRandom;
  TimeRunning.Pause;
  WL.Activity.Pause;

  try
    Result := Antiban.DoAntiban(CheckBreaks, CheckSleeps);
  finally
    TimeRunning.Resume;
    WL.Activity.Resume;

    if not RSClient.IsLoggedIn then
      Login.LoginPlayer;
  end;
end;

procedure TBaseScript.ProcessWhileWaiting;
var
  Str: String;
  ProgressArray: TStringArray;

  TitleLength: Int32;
  ElapsedTime: UInt64;
begin
  TotalProfit := (TotalActions * ActionProfit) - TotalConsumableCost;

  if (GetTickCount - StatsDebugTick) > 1000 then
  begin
    Self.DebugLn(Action, ExtraInfo);
    ElapsedTime := TimeRunning.ElapsedTime;

    Str := Name;
    TitleLength := Str.Len;

    Str    := PadL((' ' + Str + ' '), 10, ' ');
    Str    := PadR(Str, 90 - TitleLength, ' ');

    TitleLength   := Str.Len;

    ProgressArray += Str;

    ProgressArray += PadR((' Action        : ' + Action), Round(TitleLength/2), ' ') +
                           ' Runtime       : ' + SRL.MsToTime(ElapsedTime, Time_Short);

    if (ActionLimit = -1) then
      ProgressArray += PadR((' Total Actions : ' + ToStr(TotalActions)), Round(TitleLength/2), ' ') +
                             ' Actions/Hour  : ' + ToStr(NumberPerHour(TotalActions, ElapsedTime))
    else
      ProgressArray += PadR((' Total Actions : ' + ToStr(TotalActions) + '/' + ToStr(ActionLimit)), Round(TitleLength/2), ' ') +
                             ' Actions/Hour  : ' + ToStr(NumberPerHour(TotalActions, ElapsedTime));

    ProgressArray += PadR((' Total Profit  : ' + SRL.FormatNumber(TotalProfit)), Round(TitleLength/2), ' ') +
                           ' Profit/Hour   : ' + SRL.FormatNumber(NumberPerHour(TotalProfit, ElapsedTime));

    ProgressArray += ' Join WaspBots on Discord: https://waspbot.com';

    ProgressArray += ExtraInfo;

    {$IFDEF SRL_USE_REMOTEINPUT}
    if RemoteInputEnabled and ProgressReportEnabled and not ScriptDebugEnabled and
    (Action <> PreviousAction) then
      ProgressReport.Update(ProgressArray);
    {$ENDIF}

    for Str in ProgressArray do
      Writeln(Str);

    PreviousAction := Action;
    StatsDebugTick := GetTickCount;
  end
  else
  begin
    ElapsedTime := TimeRunning.ElapsedTime;

    ProgressArray += PadR((' Action        : ' + Action), Round(TitleLength/2), ' ') +
                           ' Runtime       : ' + SRL.MsToTime(ElapsedTime, Time_Short);

    if (Action <> PreviousAction) or ((pos('WAIT_',Action) < 1) and (Action = PreviousAction)) then
    for Str in ProgressArray do
      Writeln(Str);

    PreviousAction := Action;

  end;

  if ScriptDebugEnabled then
    SRL.Debug(RSClient.Image);
end;

function TBaseScript.ShouldStop: Boolean;
begin
  Result := ((ActionLimit > -1) and (TotalActions >= ActionLimit)) or
            ((TimeLimit > -1) and (TimeRunning.ElapsedTime >= TimeLimit));
end;




procedure TBaseWalkerScript.Init(MaxActions: Int32; MaxTime: Int64); override;//override me to add more stuff.
begin
  inherited;

  RSW.OnWalkingEvent := @WalkerTasks;
end;



procedure TBaseBankScript.Init(MaxActions: Int32; MaxTime: Int64); override;//override me to add more stuff.
begin
  inherited;

  BankTab := -1;
  CollectTimer.Init(600000);

  //override me to add more stuff.
end;

procedure TBaseBankScript.SetupWLBanks;
begin
  case CurrentBankLocation of
    EWaspBankLocation.AL_KHARID:
      begin
		    RSW.Setup('mainland');
		    ScriptBank := @RSObjects.AlKharidBank;
      end;

    EWaspBankLocation.ARDOUGNE_NORTH:
      begin
		    RSW.Setup('x5723y3038');
		    ScriptBank := @RSObjects.ArdougneNorthBank;
      end;

    EWaspBankLocation.ARDOUGNE_SOUTH:
      begin
		    RSW.Setup('x5723y3038');
		    ScriptBank := @RSObjects.ArdougneSouthBank;
      end;

    EWaspBankLocation.CASTLE_WARS:
      begin
		    RSW.Setup('mainland');
		    ScriptBank := @RSObjects.CastleWarsBank;
      end;

    EWaspBankLocation.CATHERBY:
      begin
		    RSW.Setup('mainland');
		    ScriptBank := @RSObjects.CatherbyBank;
      end;

    EWaspBankLocation.CRAFT_GUILD:
      begin
		    RSW.Setup('x6953y3166');
		    ScriptBank := @RSObjects.CraftGuildBank;
      end;

    EWaspBankLocation.DRAYNOR:
      begin
		    RSW.Setup('x7617y3214');
		    ScriptBank := @RSObjects.DraynorBank;
      end;

    EWaspBankLocation.EDGEVILLE:
      begin
		    RSW.Setup('x7536y2363');
		    ScriptBank := @RSObjects.EdgevilleBank;
      end;

    EWaspBankLocation.FALADOR_EAST:
      begin
		    RSW.Setup('x7051y2796');
		    ScriptBank := @RSObjects.FaladorEastBank;
      end;

    EWaspBankLocation.FALADOR_WEST:
      begin
		    RSW.Setup('x7051y2796');
		    ScriptBank := @RSObjects.FaladorWestBank;
      end;

    EWaspBankLocation.GRAND_EXCHANGE:
      begin
		    RSW.Setup('x7789y2306');
		    ScriptBank := @RSObjects.GEBank;
      end;

    EWaspBankLocation.LUNAR_ISLAND:
      begin
		    RSW.Setup('x4127y1027');
		    ScriptBank := @RSObjects.LunarBank;
      end;

    EWaspBankLocation.MINING_GUILD:
      begin
		    RSW.Setup('x6291y497');
		    ScriptBank := @RSObjects.MiningGuildBank;
      end;

    EWaspBankLocation.PRIFDDINNAS:
      begin
		    RSW.Setup('x3583y1905');
		    ScriptBank := @RSObjects.PrifddinasBank;
      end;

    EWaspBankLocation.SEERS:
      begin
		    RSW.Setup('mainland');
		    ScriptBank := @RSObjects.SeersBank;
      end;

    EWaspBankLocation.TZHAAR:
      begin
		    RSW.Setup('x4333y310');
		    ScriptBank := @RSObjects.TzhaarBank;
      end;

    EWaspBankLocation.VARROCK_EAST:
      begin
		    RSW.Setup('x7536y2363');
		    ScriptBank := @RSObjects.VarrockEastBank;
      end;

    EWaspBankLocation.VARROCK_WEST:
      begin
		    RSW.Setup('x7789y2306');
		    ScriptBank := @RSObjects.VarrockWestBank;
      end;

    EWaspBankLocation.WINTERTODT:
      begin
		    RSW.Setup('x1549y224');
		    ScriptBank := @RSObjects.WintertodtBank;
      end;
  end;
end;


function TBaseBankScript.Terminate: Boolean;//override me to add more stuff.
begin
  for 0 to 5 do
  begin
    if MainScreen.HasInterface then
    begin
      if Result := Bank.IsOpen then Break
      else MainScreen.CloseInterface;
    end;

    if Result := Bank.WalkOpen(ScriptBank) then Break;
  end;
  //override me to add more stuff.
end;

procedure TBaseBankScript.CountItemsLeft(Item: TRSItem);
begin
  ItemLeftAmount := Inventory.CountItem(Item);
end;

function TBaseBankScript.ShouldHover: Boolean;
begin
  Result := ((ItemLeftAmount = 1) and SRL.Dice(10 + (90 * BioHash))) or
            ((ItemLeftAmount = 2) and SRL.Dice(5 + (75 * BioHash))) or
            ((ItemLeftAmount = 3) and SRL.Dice(5 + (60 * BioHash))) or
            ((ItemLeftAmount = 4) and SRL.Dice(45 * BioHash)) or
            ((ItemLeftAmount = 5) and SRL.Dice(30 * BioHash)) or
            ((ItemLeftAmount = 6) and SRL.Dice(10 * BioHash)) or
            SRL.Dice(5 * BioHash);
end;


function TBaseBankScript.Hover: Boolean;
begin
  Result := HoveringBank := Bank.Hover(ScriptBank);
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  MM2MS.SetupZoom;
  if (Bitmap = RSClient.Image) then
    Bitmap.Clear;

  inherited(Bitmap);
end;


//WeaponData
type
  TRSWeaponData = record(TSRLBaseRecord)
    WikiSpecAttacks: String;

    IsSetup: Boolean;
  end;

procedure TRSWeaponData.Setup;
begin
  if IsSetup then
    Exit;
  Name := 'WeaponData';
  WikiSpecAttacks := GetPage('https://oldschool.runescape.wiki/w/Special_attacks').Lower.After('mw-headline');
end;

function TRSWeaponData.GetSpec(Weapon: TRSItem): Int32;
var
  WeaponStr: String;
  Str: String;
begin
  if not IsSetup then
    Self.Setup;

  WeaponStr := ToStr(Weapon);
  DebugLn('Getting ' + WeaponStr + ' spec data from the wiki.');

  Str :=  WikiSpecAttacks.After(WeaponStr.Lower);

  if Str = WikiSpecAttacks then
    Exit(200);

  Result := StrToInt(Str.After('energy used').After('<td>').Before('%'));

  DebugLn(WeaponStr + ' spec setup with ' + ToStr(Result) + '% energy.');
end;

var
  WeaponData: TRSWeaponData;

//CombatHandler
type
  TCombatHandler = record(TSRLBaseRecord)
    EnemyNPC: PRSNPC;
    InCombatTimer: TCountDown;
    CombatStyle: TRSCombatStyle;

    ManageWeapons: Boolean;

    Weapon: TRSItem;
    Shield: TRSItem;
    SpecWeapon: TRSItem;

    WeaponSpec: Int32;
    WeaponIsSetup: Boolean;

    QuickPrayerIsSetup: Boolean;
    IsSetup: Boolean;
  end;

procedure TCombatHandler.Setup(Timer: Int64 = 4000);
begin
  if IsSetup then
    Exit;

  Name := 'CombatHandler';

  InCombatTimer.Setup(Timer);
  ManageWeapons := False;

  IsSetup := True;
end;

procedure TCombatHandler.Setup(NPC: PRSNPC; Timer: Int64 = 4000); overload;
begin
  if IsSetup then
    Exit;

  Self.Setup(Timer);

  EnemyNPC := NPC;
end;


procedure TCombatHandler.SetupWeapons;
var
  Weapons: TRSItemArray;
  Shields: TRSItemArray;
  SpecWeapons: TRSItemArray;
begin
  if WeaponIsSetup then
    Exit;

  Weapons := [
    'Ghrazi rapier', 'Blade of saeldor (c)', 'Inquisitor''s mace',
    'Toktz-xil-ak', 'Abyssal whip', 'Abyssal bludgeon',
    'Abyssal dagger', 'Abyssal dagger (p++)', 'Saradomin sword',
    'Dragon scimitar', 'Dragon sword', 'Dragon longsword',
    'Dharok''s greataxe', 'Sarachnis cudgel', 'Dinh''s bulwark',
    'Dragon hunter lance', 'Abyssal tentacle', 'Granite hammer',
    'Bow of faerdhinen (c)',
    'Toxic blowpipe', 'Magic shortbow (i)', 'Armadyl crossbow',
    'Dragon hunter crossbow', 'Dragon crossbow', 'Rune crossbow',
    'Adamant dart', 'Mithril dart', 'Rune scimitar', 'Dorgeshuun crossbow',
    'Null'
  ];

  Shields := [
    'Avernic defender', 'Dragon defender', 'Rune defender',
    'Adamant defender', 'Mithril defender', 'Black defender',
    'Steel defender', 'Iron defender', 'Bronze defender',
    'Dragonfire shield', 'Toktz-ket-xil', 'Twisted buckler',
    'Dragonfire ward', 'Odium ward', 'Book of law',
    'Book of darkness', 'Unholy book', 'Book of war', 'Rune kiteshield', 'Null'
  ];

  SpecWeapons := [
    'Dragon claws', '4153', '12848', 'Granite maul', 'Abyssal dagger',
    'Abyssal dagger (p++)', 'Dragon dagger', 'Dragon dagger(p++)',
    'Dragon sword', 'Dragon longsword', 'Dinh''s bulwark', 'Abyssal tentacle',
    'Saradomin godsword', 'Granite hammer',
    'Toxic blowpipe', 'Magic shortbow (i)', 'Armadyl crossbow',
    'Dragon crossbow', 'Null'
  ];

  for Weapon in Weapons do
    if (Weapon = 'Null') or Equipment.FindItem(Weapon) then Break;
  DebugLn('Current weapon: ' + ToStr(Weapon) + '.');

  for Shield in Shields do
    if (Shield = 'Null') or Equipment.FindItem(Shield) then Break;
  DebugLn('Current shield: ' + ToStr(Shield) + '.');

  for SpecWeapon in SpecWeapons do
    if (SpecWeapon = 'Null') or Inventory.FindItem(SpecWeapon) then Break;
  DebugLn('Current spec weapon: ' + ToStr(SpecWeapon) + '.');

  if SpecWeapon <> 'Null' then
  begin
    case SpecWeapon of
      'Granite maul': WeaponSpec := 50;
      '4153', '12848': WeaponSpec := 60;
      else WeaponSpec := WeaponData.GetSpec(SpecWeapon);
    end;
  end
  else
  begin
    case Weapon of
      'Granite maul': WeaponSpec := 50;
      '4153', '12848': WeaponSpec := 60;
      else WeaponSpec := WeaponData.GetSpec(Weapon);
    end;

    if WeaponSpec <= 100 then
      SpecWeapon := Weapon;
  end;

  WeaponIsSetup := (Weapon <> 'Null') or (Shield <> 'Null') or (SpecWeapon <> 'Null');
end;


procedure TCombatHandler.Setup(Manage: Boolean; NPC: PRSNPC; Timer: Int64 = 4000); overload;
begin
  if IsSetup then
    Exit;

  Self.Setup(NPC, Timer);

  if ManageWeapons := Manage then
    Self.SetupWeapons;
end;


function TCombatHandler.AttackNPC: Boolean;
begin
  if EnemyNPC^.SelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.WaitInCombat(5000);
  end;

  if Result then InCombatTimer.Restart(Random(0, 3000));
end;

function TCombatHandler.WalkAttackNPC: Boolean;
begin
  if EnemyNPC^.WalkSelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.WaitInCombat(5000);
  end;

  if Result then InCombatTimer.Restart(Random(0, 3000));
end;


function TCombatHandler.CanSpec: Boolean;
begin
  if ManageWeapons and not WeaponIsSetup then
  begin
    Self.SetupWeapons;
    if not WeaponIsSetup then
      Exit;
  end;

  Result := (Minimap.GetSpecLevel >= WeaponSpec) and
            ((SpecWeapon = Weapon) or Inventory.FindItem(Weapon) or
            (Inventory.FindItem(SpecWeapon) and Inventory.HasSpace(1)));
end;

function TCombatHandler.DoSpec: Boolean;
begin
  if ManageWeapons and not WeaponIsSetup then
  begin
    Self.SetupWeapons;
    if not WeaponIsSetup then
      Exit;
  end;

  if (SpecWeapon <> Weapon) and Inventory.ClickItem(SpecWeapon) then
    if not WaitUntil(Inventory.FindItem(Weapon), 100, 4000) then
      Exit;

  Result := Minimap.EnableSpec(WeaponSpec);
  if (SpecWeapon = 'Granite maul') or
     (SpecWeapon = '4153') or
     (SpecWeapon = '12848') then Result := True;

  if Result and ((SpecWeapon <> 'Granite maul') or
                 (SpecWeapon <> '4153') or
                 (SpecWeapon <> '12848')) then
    Wait(300, 400)
  else
    Wait(50, 100);
end;


function TCombatHandler.NeedRegear: Boolean;
begin
  if not ManageWeapons or not WeaponIsSetup then
    Exit;

  Result := ((Weapon <> 'Null') and Inventory.FindItem(Weapon)) or
            ((Shield <> 'Null') and Inventory.FindItem(Shield));
end;

function TCombatHandler.ReGear: Boolean;
begin
  if not ManageWeapons or not WeaponIsSetup then
    Exit;

  if (Weapon <> 'Null') then
    Inventory.ClickItem(Weapon);
  if (Shield <> 'Null') then
    Inventory.ClickItem(Shield);

  Result := WaitUntil(not Self.NeedRegear, 100, 5000);
end;


var
  CombatHandler: TCombatHandler;

function TRSXPDrop.FindDrop: Boolean; override;
begin
  Result := inherited;

  if CombatHandler.IsSetup and Result then
    CombatHandler.InCombatTimer.Restart(Random(0, 3000));
end;

function TRSMainScreen.FindHitsplats: TRSHitsplatArray; override;
begin
  Result := inherited;

  if CombatHandler.IsSetup and (Result <> []) then
    CombatHandler.InCombatTimer.Restart(Random(0, 3000));
end;

function TRSMainScreen.FindDepletedHPBar: Boolean;
var
  Bar: TRSHPBar;
begin
  for Bar in Self.FindHPBars do
    if Bar.Percent = 0 then
      Exit(True);
end;

function TRSMainScreen.InCombat: Boolean; override;
begin
  Result := (CombatHandler.IsSetup and not CombatHandler.InCombatTimer.IsFinished)
            or XPDrop.FindDrop or (Self.FindHitsplats <> []);
end;


//ConsumableHandler
type
  TConsumableHandler = record(TSRLBaseRecord)
    ConsumableType: ERSConsumable;
    Consumable: TRSConsumableArray;
    ItemArray: TRSItemArray;

    BankTab: Int32;
    Amount: Int32;

    IsSetup: Boolean;
  end;
  TConsumableHandlerArray = array of TConsumableHandler;

  TConsumableManager = record(TSRLBaseRecord)
    Handlers: TConsumableHandlerArray;
    ItemArray: TRSItemArray;
    MinInvPoints: Int32;
    Amount: Int32;
    IsSetup: Boolean;
  end;


function GetConsumableArray(ConsumableType: ERSConsumable): TRSItemArray;
begin
  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE: Result := FOOD_ARRAY;
    ERSConsumable.PRAYER_CONSUMABLE: Result := PRAYER_ARRAY;
    ERSConsumable.ENERGY_CONSUMABLE: Result := ENERGY_ARRAY;
    ERSConsumable.BOOST_CONSUMABLE:  Result := BOOST_ARRAY;
  end;
end;

function TConsumableHandler._Setup(Item: TRSItem): TRSConsumable;
begin
  Result.Item := Item;

  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE: Result.SetupFood;
    ERSConsumable.PRAYER_CONSUMABLE: Result.SetupPrayer;
    ERSConsumable.ENERGY_CONSUMABLE: Result.SetupEnergy;
    ERSConsumable.BOOST_CONSUMABLE:  Result := [];
  end;
end;


function TConsumableHandler._FindInBank: TRSConsumableArray;
var
  Arr: TRSItemArray := GetConsumableArray(ConsumableType);
  i: Int32;
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  DebugLn('Setting up consumable of type: ' + ToStr(ConsumableType));
  for Item in Arr do
    if Bank.FindItem(Item) then
    begin
      DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self._Setup(Item);

      if not Consumable.IsParent then
        Consumable := Self._Setup(Consumable.Parent);

      Result += Consumable;

      BankTab := Bank.GetCurrentTab; //TODO: Search parent maybe?

      while not Consumable.IsLast do
      begin
        i := Arr.Find(Consumable.LeftOver);
        Consumable := Self._Setup(Arr[i]);

        Result += Consumable;
      end;
    end;
end;

function TConsumableHandler._FindInInventory: TRSConsumableArray;
var
  Arr: TRSItemArray := GetConsumableArray(ConsumableType);
  i: Int32;
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  DebugLn('Setting up consumable of type: ' + ToStr(ConsumableType));
  for Item in Arr do
    if Inventory.FindItem(Item) then
    begin
      DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self._Setup(Item);

      while not Consumable.IsParent do
        Consumable := Self._Setup(Consumable.Parent);

      Result += Consumable;

      while not Consumable.IsLast do
      begin
        i := Arr.Find(Consumable.LeftOver);
        Consumable := Self._Setup(Arr[i]);

        Result += Consumable;
      end;
    end;
end;


function TConsumableHandler.GetPoints: Int32;
var
  C: TRSConsumable;
begin
  for C in Consumable do
    Result += C.Points;
end;

procedure TConsumableHandler.Setup(ConsumType: ERSConsumable);
var
  C: TRSConsumable;
begin
  if IsSetup then
    Exit;

  ConsumableType := ConsumType;

  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE: Name := 'FoodHandler';
    ERSConsumable.PRAYER_CONSUMABLE: Name := 'PrayerHandler';
    ERSConsumable.ENERGY_CONSUMABLE: Name := 'EnergyHandler';
    ERSConsumable.BOOST_CONSUMABLE: Name := 'BoostHandler';
  end;

  BankTab := -1;

  if Inventory.Open then
    Consumable := Self._FindInInventory;

  if (Consumable = []) and Bank.IsOpen then
    Consumable := Self._FindInBank;

  for C in Consumable do
    ItemArray += C.Item;

  IsSetup := Consumable <> [];
end;




procedure TConsumableManager.SetupAmount;
var
  i: Int32;
begin
  for i := 0 to High(Handlers) do
  begin
    if Handlers[i].Amount <> 0 then
      Continue;

    if Amount = 0 then
      case MinInvPoints of
         0:  TerminateScript('FATAL: MinInvPoints or Amount have to be different from 0.');
        -1:  Handlers[i].Amount := BANK_WITHDRAW_ALL;
        -2:  Handlers[i].Amount := BANK_WITHDRAW_ALL_BUT_ONE;
        else Handlers[i].Amount := Round(MinInvPoints / Handlers[i].GetPoints);
      end
    else
      Handlers[i].Amount := Amount;
  end;
end;

procedure TConsumableManager.Setup(ConsumableType: ERSConsumable);
var
  Handler: TConsumableHandler;
begin
  if IsSetup then
    Exit;

  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE: Name := 'FoodManager';
    ERSConsumable.PRAYER_CONSUMABLE: Name := 'PrayerManager';
    ERSConsumable.ENERGY_CONSUMABLE: Name := 'EnergyManager';
    ERSConsumable.BOOST_CONSUMABLE: Name := 'BoostManager';
  end;

  DebugLn('Setting up...');

  Handler.Setup(ConsumableType);
  if Handler.IsSetup then
  begin
    Handlers += Handler;
    ItemArray := Handler.ItemArray;
    Self.SetupAmount;
  end;

  IsSetup := Handler.IsSetup;
end;

procedure TConsumableManager.SetupNew(ConsumableType: ERSConsumable);
var
  Handler: TConsumableHandler;
  i: Int32;
begin
  Handler.Setup(ConsumableType);
  if Handler.IsSetup then
  begin
    for i := 0 to High(Handlers) do
      if Handlers[i].Consumable = Handler.Consumable then
        Exit;
    Handlers += Handler;
    ItemArray.Extend(Handler.ItemArray);
    Self.SetupAmount;
  end;
end;


var
  FoodManager: TConsumableManager;
  PrayerManager: TConsumableManager;
  EnergyManager: TConsumableManager;
  BoostManager: TConsumableManager;

function GetHandler(ConsumableType: ERSConsumable): ^TConsumableManager;
begin
  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE: Result := @FoodManager;
    ERSConsumable.PRAYER_CONSUMABLE: Result := @PrayerManager;
    ERSConsumable.ENERGY_CONSUMABLE: Result := @EnergyManager;
    ERSConsumable.BOOST_CONSUMABLE:  Result := @BoostManager;
  end;

  Result^.Setup(ConsumableType);
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
begin
  if not HandlerManager^.IsSetup then
    Exit;

  Result := Self.FindItems(HandlerManager^.ItemArray.Reversed, Slots);
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.FindConsumable(ConsumableType, Slots);
end;


function TRSInventory.Consume(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
  i, j, StartingPoints: Int32;
  LastConsumable: TRSConsumable;
  TrashSlots: TIntegerArray;
begin
  if not HandlerManager^.IsSetup then
    Exit;

  case ConsumableType of
    ERSConsumable.HEALTH_CONSUMABLE:
      StartingPoints := Minimap.GetHPLevel;

    ERSConsumable.PRAYER_CONSUMABLE:
      StartingPoints := Minimap.GetPrayerLevel;

    ERSConsumable.ENERGY_CONSUMABLE:
      StartingPoints := Minimap.GetRunEnergy;
  end;

  for i := 0 to High(HandlerManager^.Handlers) do
  begin
    if (Slots <> []) or Self.FindItems(HandlerManager^.Handlers[i].ItemArray.Reversed, Slots) then
      Break;

    if i = High(HandlerManager^.Handlers) then
      Exit;
  end;

  Result := Self.ClickSlot(Slots[0], ['Eat', 'Drink']);

  if Result then
    case ConsumableType of
      ERSConsumable.HEALTH_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetHPLevel, 100, 3000);

      ERSConsumable.PRAYER_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetPrayerLevel, 100, 3000);

      ERSConsumable.ENERGY_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetRunEnergy, 100, 3000);
    end;

  if Result then
  begin
    LastConsumable := HandlerManager^.Handlers[i].Consumable[High(HandlerManager^.Handlers[i].Consumable)];
    TotalConsumableCost += LastConsumable.Cost;

    if LastConsumable.LeftOverIsTrash then
      if WaitUntil(Inventory.FindItem(LastConsumable.LeftOver, TrashSlots), 50, 650) then
      begin
        if Bank.IsOpen then
          Bank.DepositSlot([TrashSlots[0], BANK_DEPOSIT_ALL], False)
        else
          Inventory.ShiftDrop(TrashSlots);
      end;

    for i := 0 to High(TrashSlots) do
    begin
      j := Slots.Find(TrashSlots[i]);
      if j > -1 then
        Slots.Del(j);
    end;
  end;
end;

function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.Consume(ConsumableType, Slots);
end;


function TRSInventory.CountConsumable(ConsumableType: ERSConsumable): Int32;
var
  Slots: TIntegerArray;
begin
  Self.FindConsumable(ConsumableType, Slots);

  Result := Length(Slots);
end;

function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): T2DIntegerArray;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
  i: Int32;
  Item: TRSItem;
  IntArray: TIntegerArray;
begin
  if not HandlerManager^.IsSetup then
    Exit;

  for i := 0 to High(HandlerManager^.Handlers) do
  begin
    for Item in HandlerManager^.Handlers[i].ItemArray do
      IntArray += Self.CountItem(Item);
    Result += IntArray;
  end;
end;


function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
  ConsumableAmounts: T2DIntegerArray;
  i, e: Int32;
begin
  ConsumableAmounts := Self.CountEachConsumable(ConsumableType);
  if ConsumableAmounts = [] then
    Exit(0);

  for i := 0 to High(ConsumableAmounts) do
    for e := 0 to High(ConsumableAmounts[i]) do
      Result += HandlerManager^.Handlers[i].Consumable[e].Points * ConsumableAmounts[i][e];
end;

function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
begin
  Result := Self.CountPoints(ConsumableType) >= HandlerManager^.MinInvPoints;
end;


function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
begin
  if not HandlerManager^.IsSetup then
    Exit;

  Result := Self.FindItems(HandlerManager^.ItemArray);
end;

function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Idx: Int32): Int32;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
begin
  case HandlerManager^.Handlers[Idx].Amount of
    BANK_WITHDRAW_ALL: Result := BANK_WITHDRAW_ALL;
    BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
    else
      Result := Ceil((HandlerManager^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / HandlerManager^.Handlers[Idx].GetPoints);
  end;
end;

function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
  i: Int32;
  WithdrawAmount: Int32;
begin
  for i := 0 to High(HandlerManager^.Handlers) do
  begin
    if not Self.FindConsumable(ConsumableType) and not HandlerManager^.IsSetup then
      Exit;

    WithdrawAmount := Self.WithdrawConsumableAmount(ConsumableType, i);

    if WithdrawAmount <> 0 then
      Bank.WithdrawItem(HandlerManager^.Handlers[i].BankTab, [HandlerManager^.Handlers[i].ItemArray[0], WithdrawAmount, False], False);

    Result := WaitUntil(Inventory.HasEnoughConsumable(ConsumableType), 100, 3000);
  end;
end;
