(*
# Minimap to MainScreen
Methods to handle MM2MS (Minimap to MainScreen). Extends SRL's MM2MS.
*)
{$DEFINE WL_MM2MS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}


procedure TRSMainScreenShapeArray.SetShape(tile: Vector3; index: Int32 = -1);
begin

  if index > -1 then
  begin
    Self[index].Tile := tile;
    Exit;
  end;

  for index := 0 to High(Self) do
    Self[index].Tile := tile;
end;

procedure TRSMainScreenShapeArray.SetAngle(angle: Double; index: Int32 = -1);
begin
  if index > -1 then
  begin
    Self[index].Angle := angle;
    Exit;
  end;

  for index := 0 to High(Self) do
    Self[index].Angle := angle;
end;

function TRSMainScreenShapeArray.GetShape(height: Double): TRSMainScreenShapeArray;
var
  i: Int32;
  temp: TRSMainScreenShape;
begin
  for i := 0 to High(Self) do
  begin
    temp := Self[i];
    temp.Tile.Z := height;
    Result += temp;
  end;
end;

function TRSMainScreenShapeArray.ZeroHeight(): Boolean;
var
  i: Int32;
begin
  Result := True;
  for i := 0 to High(Self) do
    if Self[i].Tile.Z <> 0 then
      Exit(False);
end;


function TRSMainScreen.GetPlayerBox(x1: Double; x2: Double; y1: Double; y2: Double): TBox; overload;
var
  angle: Double;
  tpa: TPointArray;
begin
  angle := Minimap.GetCompassAngle(False);
  with Minimap.Center() do
    tpa := [Minimap.VectorToMS(Vec3(X - x1, Y, y1), angle),
            Minimap.VectorToMS(Vec3(X + x2, Y, -y2), angle)];

  Result := tpa.Bounds();
  Result.LimitTo(MainScreen.Bounds());
end;

function TRSMainScreen.GetPlayerBox(size: Double; y1: Double = 10; y2: Double=3): TBox; overload;
begin
  Result := Self.GetPlayerBox(size, size, y1, y2);
end;


(*
## MM2MS.SetupZoom
```pascal
procedure TMM2MS.SetupZoom;
```

Wrapper procedure to easily setup MM2MS.ZoomLevel.

Example:
```pascal
MM2MS.SetupZoom;
WriteLn MM2MS.ZoomLevel;
```
*)
procedure TMM2MS.SetupZoom();
begin
  if Self.ZoomLevel > -1 then
    Exit;

  Self.DebugLn('Unknown zoom level, reading from options...');
  Self.ZoomLevel := Options.GetZoomLevel();
  Self.DebugLn('Current zoom level: ' + ToString(Self.ZoomLevel));
end;


(*
## Minimap.GetFaceablePoints
```pascal
function TRSMinimap.GetFaceablePoints(): TPointArray;
```

Gives the center point of the 8 tiles that are directly close to the player.
This are the tiles the player can "face".
*)
function TRSMinimap.GetFaceablePoints(): TPointArray;
var
  p: TPoint;
begin
  p := Self.Center();
  Result := [
    [p.X, p.Y - 4], [p.X + 4, p.Y - 4], [p.X + 4, p.Y], [p.X + 4, p.Y + 4],
    [p.X, p.Y + 4], [p.X - 4, p.Y + 4], [p.X - 4, p.Y], [p.X - 4, p.Y - 4]
  ];

  Result := Result.Rotate(Self.GetCompassAngle(False), p);
end;

(*
## Minimap.GetCardinalPoints
```pascal
function TRSMinimap.GetCardinalPoints(): TPointArray;
```

Gives the center point of the 4 cardinal points (North, West, South and East) that are directly close to the player.
This are the tiles the player can "face".
*)
function TRSMinimap.GetCardinalPoints(): TPointArray;
var
  p: TPoint;
begin
  p := Self.Center();
  Result := [[p.X, p.Y - 4], [p.X + 4, p.Y], [p.X, p.Y + 4], [p.X - 4, p.Y]];
  Result := Result.Rotate(Self.GetCompassAngle(False), p);
end;


(*
## Minimap.PointWithinZoom
```pascal
function TRSMinimap.PointWithinZoom(p: TPoint; out Corner: TPoint): Boolean;
```
```pascal
function TRSMinimap.PointWithinZoom(p: TPoint): Boolean; overload;
```
```pascal
function TRSMinimap.PointWithinZoom(tpa: TPointArray): Boolean; overload;
```

Method used to know if a point is within reach of the Zoom rectangle without adjusting the zoom level.
Check TRSMinimap.GetZoomRectangle for information on the Zoom rectangle.

Example:
```pascal
WriteLn Minimap.PointWithinZoom([620, 100]);
```
*)
function TRSMinimap.PointWithinZoom(p: TPoint; out corner: TPoint): Boolean;
var
  tpa: TPointArray;
begin
  if not Self.IsPointOn(p) then
    Exit;

  tpa := Self.GetZoomRectangle().ToTPA().SortFrom(Self.Center());
  corner := tpa[High(tpa)];

  Result := Self.Center().DistanceTo(P) <= Self.Center().DistanceTo(corner);
end;

function TRSMinimap.PointWithinZoom(p: TPoint): Boolean; overload;
var
  corner: TPoint;
begin
  Result := Self.PointWithinZoom(p, corner);
end;

function TRSMinimap.PointWithinZoom(tpa: TPointArray): Boolean; overload;
begin
  if tpa = [] then
    Exit;

  tpa := tpa.SortFrom(Self.Center());
  Result := Self.PointWithinZoom(tpa.First());
end;


(*
## Minimap.GetZoomToPoint
```pascal
function TRSMinimap.GetZoomToPoint(p: TPoint; randomness: Int32 = 0): Int32;
```

TODO: THIS NEEDS TO BE REWORKED. IT'S NOT RELIABLE RIGHT NOW.

This function gives us a zoom level where **P** would be visible in the MainScreen.

Example:
```pascal
p := Minimap.GetDots(ERSMinimapDot.ITEM)[0]; //find an item dot and returns it's coodinates.
Options.SetZoomLevel(Minimap.ZoomToVisiblePoint(p));
```
*)
function TRSMinimap.GetZoomToPoint(p: TPoint; randomness: Int32 = 0): Int32;
var
  distance: Double;
begin
  distance := p.DistanceTo(Self.Center());

  Result := Round((73 - distance) / 0.8);
  Result := Result + randomness;
end;

(*
## Minimap.SetZoomToPoint
```pascal
function TRSMinimap.SetZoomToPoint(p: TPoint; randomness: Int32 = 0): Boolean;
```

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

This function adjusts the zoom level so **P** TRSMinimap.PointWithinZoom() is true.
*)
function TRSMinimap.SetZoomToPoint(p: TPoint; randomness: Int32 = 0): Boolean;
var
  level: Int32;
begin
  if Self.PointWithinZoom(p) then
    Exit(True);

  level := Self.GetZoomToPoint(p, randomness);

  if (Antiban.MaxZoom = 0) then
    Antiban.MaxZoom := 100;

  if InRange(level, Antiban.MinZoom, Antiban.MaxZoom) then
    Result := RSMouseZoom.SetZoomLevel(level);
end;


(*
## Minimap.MakePointVisible
```pascal
function TRSMinimap.MakePointVisible(p: TPoint): Boolean;
```
```pascal
function TRSMinimap.MakePointVisible(tpa: TPointArray): Boolean; overload;
```

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

Uses both Minimap.ZoomToPoint() and Minimap.FacePoint() to make a point visible on the Mainscreen.
*)
function TRSMinimap.MakePointVisible(p: TPoint): Boolean;
begin
  Result := Self.SetZoomToPoint(p, Random(-5, 5)) and Self.FacePoint(p, Random(-3, 3));
end;

function TRSMinimap.MakePointVisible(tpa: TPointArray): Boolean; overload;
begin
  Result := Self.MakePointVisible(tpa.SortFrom(Self.Center()));
end;

