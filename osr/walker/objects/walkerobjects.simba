(*
# Walker Objects
Methods to handle TRSWalkerObjects.
TRSWalkerObject can be anything that you want to interact with on the mainscreen.
They are divided in 2 main categories and one of them in 3 sub-categories but the usage is only limited by your imagination:
  - RSObjects (TRSWalkerObjects that don't have a dot on the minimap)
  - MMDots:   (TRSWalkerObjects that have a dot on the minimap)
    -RSNPCs
    -RSGroundItems
    -RSPlayers

## How do they work?
TRSWalkerObjects are very customizable and can be used to interact with almost everything.
For some niche use cases it might be worth do something custom or override some methods to get the behavior you want.

The default way they work is:
- WaspLib checks if you are in the TRSWalkerObject.Coordinates range.
  If not and you used one of the **Walk** methods, it will walk to that location.
- Being in the TRSWalkerObject location, then we check if our TRSWalkerObject is a TRSObject or a TRSMMDot.
  for a TRSObject we stick with the TRSWalkerObject.Coordinates, for TRSMMDots, the coordinates are changed to the minimap dots that within the radius specified when the TRSWalkerObject was setup.
- WaspLib then convert the coordinate along with the TRSWalkerObject.ShapeArray information to a TCuboidArray on the mainscreen (https://en.wikipedia.org/wiki/Cuboid).
- This TCuboidArray is the "bounds" of our targets. Each one should accurately surround each of our possible targets.
- Then WaspLib runs MainScreen.FindObject() inside of each TCuboid. For more info on how this works read the TRSObjectFinder documentation (https://torwent.github.io/SRL-T/mainscreen.html#type-trsobjectfinder).
- An ATPA of the found colors inside each cuboid is then returned.
- If the method used is related to hovering or clicking, we hover the closest target and then check if TRSWalkerObject.UpText matches the uptext.
- If it does and we are using a clicking method, we click it.
- If we use a **select** method, if the option is not in the uptext we right click the target and select that option.


This is the default behavior but TRSWalkerObjects are very customizable and functionality can be toggled on with TRSWalkerObject.Filter:
- Filter.Walker: Disables walker for the TRSWalkerObject. Coordinates are ignored and still use the minimap dots that are visible on the
  minimap if we are talking about a TRSMMDot, otherwise only MainScreen.FindObject() is used.
- Filter.MinimapDot: Disables the usage of minimap dots for TRSMMDots. TRSObjects have this off by default. Disabling this for TRSMMDots is only useful if the the Player, NPC or Item is in a fixed position.
- Filter.Finder: Disables color checking. The returned cuboids by Walker and MM2MS are our targets. This is useful for things that are "invisible" like agility shortcuts and/or things that have colors that are just unreliable.
- UpText: Ignore all uptext when hovering the targets
- Filter.Skip: This is an internal filter that you probably don't want to use directaly. Decides which TRSWalkerObjects setup is skipped during wasplib's setup process.

```{note}
You cannot disable Filter.Walker, Filter.MinimapDot, Filter.Finder all at the same time. You need one of them enabled and keep in mind that TRSObjects already have Filter.MinimapDot disabled.
```
*)
{$DEFINE WL_WALKEROBJECT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

const
  TRACK_TARGET: Boolean = True;

type
(*
(TRSWalkerObject)=
## type TRSWalkerObject
```pascal
TRSWalkerObject = record
  Filter: record
    Walker:     Boolean;
    MinimapDot: Boolean;
    Finder:     Boolean;
    UpText:     Boolean;
    Skip:       Boolean;
  end;

  ShapeArray: TRSMainScreenShapeArray;
  Coordinates: TPointArray;

  Finder: TRSObjectFinder;
  UpText: TStringArray;
  ActionUpText: TStringArray;
class var
  CurrentUpText: TStringArray;
  CurrentActionUpText: TStringArray;
  RedClicked: Boolean;
end;

PWalkerObjectArray = array of Pointer;
PRSWalkerObject = ^TRSWalkerObject;
```
Parent record of all TRSWalkerObjects.
*)
  TRSWalkerObject = record
    Filter: record
      Walker:     Boolean;
      MinimapDot: Boolean;
      Finder:     Boolean;
      UpText:     Boolean;
      Skip:       Boolean;
    end;

    ShapeArray: TRSMainScreenShapeArray;
    Coordinates: TPointArray;

    Finder: TRSObjectFinder;
    UpText: TStringArray;
    ActionUpText: TStringArray;
  class var
    CurrentUpText: TStringArray;
    CurrentActionUpText: TStringArray;
    RedClicked: Boolean;
  end;

  PWalkerObjectArray = array of Pointer;
  PRSWalkerObject = ^TRSWalkerObject;

(*
## Walker.Click
```pascal
function TRSWalker.Click(minimapPoint: TPoint; Randomness: Int32): Boolean; override;
```

You shouldn't modify this unless you know what you are doing, otherwise you might break TRSWalkerObjects.
This is overriden so if we redclick our current TRSWalkerObject target while mainscreen walking we disable walker.
When we start the walking process towards a TRSWalkerObject, TRSWalkerObject.CurrentUpText is temporarily set so we
know what we are looking for while walking. Once we click the target TRSWalkerObject.CurrentUpText is cleared.
*)
function TRSWalker.Click(minimapPoint: TPoint; randomness: Int32): Boolean; override;
var
  p: TPoint;
  hoveringTarget: Boolean;
  upText: String;
begin
  if MainScreen.IsUpText('>') and not TRSWalkerObject.CurrentUpText.ContainsAny(['Use', '>']) then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  Result := True;
  Self.CheckRunEnergy();

  if Self.ScreenWalk then
  begin
    p := Minimap.RandomPointOnZoomRectangle(minimapPoint, randomness);
    Mouse.Move(Minimap.PointToMSRect(p).Mean());
    upText := MainScreen.GetUpText();

    hoveringTarget := upText.ContainsAny(TRSWalkerObject.CurrentUpText);
    if hoveringTarget and (TRSWalkerObject.CurrentActionUpText <> []) then
    begin
      hoveringTarget := upText.ContainsAny(TRSWalkerObject.CurrentActionUpText);
      if not hoveringTarget then
      begin
        TRSWalkerObject.RedClicked := ChooseOption.Select(TRSWalkerObject.CurrentActionUpText);
        if TRSWalkerObject.RedClicked then
          Self.Enabled := False;
        Exit(TRSWalkerObject.RedClicked);
      end;
    end
    else if not upText.ContainsAny(Self.WalkUpText) then
      Exit(ChooseOption.Select('Walk here'));
  end
  else
    Mouse.Move(Minimap.RandomPointOn(minimapPoint, randomness));

  if randomness > 0 then
    Antiban.BioClick(MOUSE_LEFT)
  else
    Mouse.Click(MOUSE_LEFT);

  TRSWalkerObject.RedClicked := Self.ScreenWalk and hoveringTarget and MainScreen.DidRedClick();

  if TRSWalkerObject.RedClicked then
    Self.Enabled := False;
end;

(*
## TRSWalkerObject._Setup
```pascal
procedure TRSWalkerObject._Setup();
```

Base internal TRSWalkerObject setup method. You probably won't need to call this directly, it's called by the next setup methods automatically.
*)
procedure TRSWalkerObject._Setup();
begin
  Self.Filter.Finder     := True;
  Self.Filter.UpText     := True;
end;

(*
## TRSWalkerObject.Setup
```pascal
procedure TRSWalkerObject.Setup(coordinates: TPointArray);
procedure TRSWalkerObject.Setup(upText: TStringArray); overload;
```

TRSWalkerObject setup methods. You usually need to call of this.

The method that takes in coordinates should be called first.
That is because `TRSWalkerObject.Setup(coordinates: TPointArray)` is where
we decide if TRSWalkerObject.Filter.Skip is going to be true or not.

Keep in mind if you don't use a TRSWalker in your script and want to use TRSWalkerObjects, you will need to manually setup them in your script
because they will all be skipped.
So you need to set `TRSWalkerObject.Filter.Skip := False` and then call `TRSWalkerObject.Setup(upText: TStringArray)`

Normal usage in the following example.

Example:
```pascal
//Example with walker:
var
  rsw: TRSWalker;
  obj: TRSObject; //This is a type of TRSWalkerObject.
begin
  rsw.Setup();
  obj.Setup([[200, 200]]);
  obj.Setup(['My', 'uptext']);
end;


//Example without walker:
var
  obj: TRSObject; //This is a type of TRSWalkerObject.
begin
  obj.Setup(['My', 'uptext']);
end;
```
*)
procedure TRSWalkerObject.SetupCoordinates(coordinates: TPointArray);
begin
  Self.Filter.Skip := ScriptWalker = nil;

  if Self.Filter.Skip then
    Exit;

  coordinates := ScriptWalker^.Regions.Filter(coordinates);

  Self.Filter.Skip := coordinates = [];
  if Self.Filter.Skip then
    Exit;

  Self.Filter.Walker := True;
  Self.Coordinates := coordinates;
  SetLength(Self.ShapeArray, Length(coordinates));
end;

procedure TRSWalkerObject.SetupUpText(upText: TStringArray);
begin
  if Self.Filter.Skip then
    Exit;

  Self._Setup();

  Self.UpText := upText;

  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;
end;

procedure TRSWalkerObject.Setup(coordinates: TPointArray); deprecated 'Use TRSWalkerObject.SetupCoordinates() instead.';
begin
  Self.SetupCoordinates(coordinates);
end;

procedure TRSWalkerObject.Setup(upText: TStringArray); overload; deprecated 'Use TRSWalkerObject.SetupUpText() instead.';
begin
  Self.SetupUpText(upText);
end;

(*
## TRSWalkerObject.GetCuboidArray
```pascal
function TRSWalkerObject.GetCuboidArray(): TCuboidArray;
```
Internal TRSWalkerObject method responsible for returning a TCuboidArray of our target on the 3D world (on mainscreen and outside of it).
You will probably never need to use this directly.
You can visually see this in action by using the `Debug()` methods, this is responsible for the white lines surounding the targets.
*)
function TRSWalkerObject.GetCuboidArray(me: TPoint = []): TCuboidExArray;
var
  coordinates: TPointArray;
begin
  if me = [] then
    me := ScriptWalker^.GetMyPos();

  coordinates := Self.Coordinates.PointsInRangeOf([me],0, 120);
  coordinates := coordinates.Sorted(me);

  //This is extremely wrong but will stay for now. shapearray should also be sorted and cropped.
  Result := ScriptWalker^.GetCuboidArrayMS(me, coordinates, Self.ShapeArray, [0, 0]);
end;

(*
## TRSWalkerObject.FindOnMainScreen
```pascal
function TRSWalkerObject.FindOnMainScreen(cuboidArray: TCuboidArray): T2DPointArray;
```

Internal TRSWalkerObject method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSWalkerObject.GetCuboidArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSWalkerObject.FindOnMainScreen(cuboidArray: TCuboidExArray): T2DPointArray;
var
  i: Int32;
  tpa: TPointArray;
  tmpFinder: TRSObjectFinder;
begin
  if Self.Filter.Finder then
    tmpFinder := Self.Finder.Unlimited();

  cuboidArray := MainScreen.Filter(cuboidArray);

  RSClient.Clear(MainScreen.Bounds());

  for i := 0 to High(cuboidArray) do
  begin
    if Self.Filter.Finder then
    begin
      RSClient.DrawCuboid(cuboidArray[i], $FFFFFF, 1);

      tpa := MainScreen.FindObject(tmpFinder, cuboidArray[i].Bounds()).Merge();
      if tpa = [] then
        Continue;

      tpa := cuboidArray[i].Filter(tpa);
      if tpa <> [] then
      begin
        Result += tpa;
        RSClient.DrawTPA(tpa, $0000FF);
      end;

      Continue;
    end;

    tpa := cuboidArray[i].ShapeFill();
    if tpa <> [] then
    begin
      if WLSettings.RemoteInput.HUDDebug then
      begin
        RSClient.DrawTPA(tpa, $0000FF);
        RSClient.DrawCuboid(cuboidArray[i], $FFFFFF, 1);
      end;
      Result += tpa;
    end;
  end;
end;

(*
## TRSWalkerObject.OnMainScreen
```pascal
function TRSWalkerObject.OnMainScreen(cuboidArray: TCuboidArray): Boolean;
```

Internal TRSWalkerObject method that returns true or false if we have TCuboids visible on the mainscreen.
You probably don't need to use this directly.
*)
function TRSWalkerObject.OnMainScreen(cuboidArray: TCuboidExArray): Boolean;
var
  i: Int32;
  tempFinder: TRSObjectFinder;
begin
  if Self.Filter.Finder then
    tempFinder := Self.Finder.Unlimited();

  cuboidArray := MainScreen.Filter(cuboidArray);

  if not Self.Filter.Finder then
    Exit(cuboidArray <> []);

  RSClient.Clear(MainScreen.Bounds());

  for i := 0 to High(cuboidArray) do
  begin
    RSClient.DrawCuboid(cuboidArray[i], $FFFFFF, 1);

    if MainScreen.FindObject(tempFinder, cuboidArray[i].Bounds()) <> [] then
      Exit(True);
  end;
end;


(*
## TRSWalkerObject._UpTextCheck
```pascal
function TRSWalkerObject._UpTextCheck(out shouldExit: Boolean): Boolean;
```

Internal TRSWalkerObject helper method that is used by all hovering methods.
You probably don't need to use this directly.
*)
function TRSWalkerObject._UpTextCheck(out shouldExit: Boolean): Boolean;
var
  strArray: TStringArray;
  upText: String;
begin
  shouldExit := True;

  if (MainScreen.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface() then
    Exit;

  if Self.Filter.UpText then
  begin
    strArray := Self.UpText;
    if Self.ActionUpText <> [] then
      strArray := Self.ActionUpText;

    if TRSWalkerObject.CurrentUpText <> strArray then
      TRSWalkerObject.CurrentUpText := strArray;
  end;

  upText := MainScreen.GetUpText();

  if ('>' in upText) and not TRSWalkerObject.CurrentUpText.Contains('Use') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  if Self.Filter.UpText and (Self.UpText in upText) then
    Exit(True);

  shouldExit := False;
end;

(*
## TRSWalkerObject._WalkUpTextCheck
```pascal
function TRSWalkerObject._WalkUpTextCheck(out shouldExit: Boolean): Boolean;
```

Internal TRSWalkerObject helper method that is used by all walking hover methods.
You probably don't need to use this directly.
*)
function TRSWalkerObject._WalkUpTextCheck(out shouldExit: Boolean): Boolean;
var
  upText: String;
  strArray: TStringArray;
begin
  shouldExit := True;

  if (MainScreen.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface() then
    Exit;


  if Self.Filter.UpText then
  begin
    strArray := Self.UpText;
    if Self.ActionUpText <> [] then
      strArray := Self.ActionUpText;

    if TRSWalkerObject.CurrentUpText <> strArray then
      TRSWalkerObject.CurrentUpText := strArray;
  end;

  upText := MainScreen.GetUpText();

  if ('>' in upText) and not TRSWalkerObject.CurrentUpText.Contains('Use') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  if TRSWalkerObject.RedClicked or (Self.Filter.UpText and (Self.UpText in upText)) then
    Exit(True);

  shouldExit := False;
end;


(*
## TRSWalkerObject._ClickHelper
```pascal
function TRSWalkerObject._ClickHelper(leftClick: Boolean): Boolean;
```

Internal TRSWalkerObject helper method that is used by other clicking methods.
You probably don't need to use this directly.

This is what's responsible for deciding if we click a target we are hovering or not.
*)
function TRSWalkerObject._ClickHelper(leftClick: Boolean): Boolean;
begin
  TRSWalkerObject.CurrentUpText := [];
  TRSWalkerObject.CurrentActionUpText := [];

  if TRSWalkerObject.RedClicked then
  begin
    TRSWalkerObject.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick() or
            (not leftClick and Self.Filter.UpText and ChooseOption.Select(Self.UpText));

  if Result and SRL.Dice(0.5 - (0.5 * BioHash)) then
  begin
    case Random of
      0.000..0.899: Antiban.SmallRandomMouse();
      else Antiban.RandomMouse();
    end;
  end;
end;

(*
## TRSWalkerObject._SelectHelper
```pascal
function TRSWalkerObject._SelectHelper(action: TStringArray): Boolean;
```

Internal TRSWalkerObject helper method that is used by other select methods.
You probably don't need to use this directly.

This is what is responsible for deciding if we just left click a target we are hovering or right click it and choose an option.
*)
function TRSWalkerObject._SelectHelper(action: TStringArray): Boolean;
begin
  TRSWalkerObject.CurrentUpText := [];
  TRSWalkerObject.CurrentActionUpText := [];

  if TRSWalkerObject.RedClicked then
  begin
    TRSWalkerObject.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Exit(MainScreen.DidRedClick());
  end;

  Result := ChooseOption.Select(action);
end;


function PWalkerObjectArray.GetClosestEx(value: TPoint): PRSWalkerObject;
var
  i: Int32;
  tmp: PRSWalkerObject;
  closest: Double = $FFFFFF;
  current: Double;
begin
  for i := High(Self) downto 0 do
  begin
    tmp := PRSWalkerObject(Self[i]);
    if tmp^.Coordinates = [] then
    begin
      Delete(Self, i, 1);
      Continue;
    end;

    current := tmp^.Coordinates.NearestPoint(value).DistanceTo(value);
    if current < closest then
    begin
      closest := current;
      Result := tmp;
    end;
  end;
end;

function PWalkerObjectArray.GetClosest(): PRSWalkerObject;
begin
  if (Self = []) or (ScriptWalker = nil) then
    Exit;

  Result := Self.GetClosestEx(ScriptWalker^.GetMyPos());
end;


type
(*
(TRSObject)=
## type TRSObject
```pascal
TRSObject = type TRSWalkerObject;
TRSObjectArray = array of TRSObject;
PRSObject = ^TRSObject;
PRSObjectArray = array of PRSObject;
```
TRSObjects are a type of {ref}`TRSWalkerObject`.
This are meant to be TRSWalkerObjects that do not have a minimap dot so TRSObject.Filter.MinimapDot is False by default and shouldn't be changed.
*)
  TRSObject = type TRSWalkerObject;
  TRSObjectArray = array of TRSObject;
  PRSObject = ^TRSObject;
  PRSObjectArray = array of PRSObject;

(*
## TRSObject.Setup
```pascal
procedure TRSObject.SetupEx(shape: Vector3; coordinates: TPointArray); overload;
procedure TRSObject.Setup(size, height: Double; coordinates: TPointArray); overload;
procedure TRSObject.Setup(height: Double; coordinates: TPointArray); overload;
```

All this extend the basic `TRSWalkerObject.Setup(coordinates: TPointArray)`.
For TRSObjects this are the methods that should be used for setting them up initially.

In TRSObject.Setup(shape: Vector3; coordinates: TPointArray), **shape** should be a vector3 of the object shape in number of tiles:
- shape.X: number of tiles of the object from west to east.
- shape.Y: number of tiles of the object from north to south.
- shape.Z: object height, this value has to be guessed, I recommend you try several values and debug it until it looks good to you.
           As some examples, player and npcs height is around 7, bank chests 4, yew/magic trees 14/16.

In TRSObject.Setup(size, height: Double; coordinates: TPointArray), **size** and **height** are used
to create a Vector3 "shape" and call TRSObject.Setup(shape: Vector3; coordinates: TPointArray).
In this case, **shape.X** and **shape.Y** would be both equal to **size**.

Lastly, TRSObject.Setup(height: Double; coordinates: TPointArray) also calls TRSObject.Setup(shape: Vector3; coordinates: TPointArray)
and sets the **shape.X** and **shape.Y** to 1.
*)
procedure TRSObject.SetupEx(shape: Vector3; coordinates: TPointArray); overload;
begin
  Self.SetupCoordinates(coordinates);

  if Self.Filter.Skip then
    Exit;

  Self.ShapeArray.SetShape(shape);
end;

procedure TRSObject.Setup(size, height: Double; coordinates: TPointArray); overload;
begin
  Self.SetupEx([size, size, height], coordinates);
end;

procedure TRSObject.Setup(height: Double; coordinates: TPointArray); overload;
begin
  Self.Setup(1, height, coordinates);
end;


(*
## TRSObject.Find
```pascal
function TRSObject.FindEx(out cuboids: TCuboidArray; out atpa: T2DPointArray): Boolean;
function TRSObject.Find(out atpa: T2DPointArray): Boolean;
```
TRSObject method used to find a {ref}`TRSObject`. If found returns true, if not returns false.
The "extended" method in particular is mostly meant for debugging and is the one used when you call `Debug(TRSObject)`.

Example:
```pascal
WriteLn RSObjects.GEBank.Find(atpa); //Be in ge and with a walker setup there.
Debug(atpa);
```
*)
function TRSObject.FindEx(out cuboids: TCuboidExArray; out atpa: T2DPointArray): Boolean;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker then
  begin
    cuboids := Self.GetCuboidArray();
    if cuboids = [] then
      Exit;

    atpa := Self.FindOnMainScreen(cuboids);
  end
  else if Self.Filter.Finder then
    atpa := MainScreen.FindObject(Self.Finder).SortFrom(MainScreen.GetPlayerBox().Center());

  Result := atpa <> [];
end;

function TRSObject.Find(out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidExArray;
begin
  Result := Self.FindEx(cuboids, atpa);
end;

(*
## TRSObject.IsVisible
```pascal
function TRSObject.IsVisible(): Boolean;
```
TRSObject method used to find a {ref}`TRSObject`. If found returns true, if not returns false.

Example:
```pascal
WriteLn RSObjects.GEBank.IsVisible(); //Be in ge and with a walker setup there.
```
*)
function TRSObject.IsVisible(): Boolean;
var
  cuboids: TCuboidExArray;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker then
  begin
    cuboids := Self.GetCuboidArray();

    if cuboids = [] then
      Exit;

    Exit(Self.OnMainScreen(cuboids));
  end;

  if Self.Filter.Finder then
    Result := MainScreen.FindObject(Self.Finder) <> [];
end;

(*
## TRSObject.FindFromPosition
```pascal
function TRSObject.FindFromPosition(me: TPoint; out atpa: T2DPointArray): Boolean;
```
Look for a {ref}`TRSObject` as if you were on a different position. Great for things like pre-hovering.
*)
function TRSObject.FindFromPosition(me: TPoint; out atpa: T2DPointArray): Boolean;
var
  cuboidArray: TCuboidExArray;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker then
  begin
    cuboidArray := Self.GetCuboidArray(me);

    if cuboidArray = [] then
      Exit;

    atpa := Self.FindOnMainScreen(cuboidArray);
  end;

  Result := atpa <> [];
end;


(*
## TRSObject.Draw
```pascal
procedure TRSObject.Draw(out bitmap: TMufasaBitmap);
```

Internal method used to draw found TRSObjects in a TMufasaBitmap.

Example:
```pascal
Bitmap.FromClient()
RSObjects.GEBank.Draw(Bitmap); //Be in ge and with a walker setup there.
Bitmap.Debug();
Bitmap.Free();
```
*)
procedure TRSObject.Draw(out bitmap: TMufasaBitmap);
var
  cuboids: TCuboidExArray;
  atpa: T2DPointArray;
begin
  Self.FindEx(cuboids, atpa);

  bitmap.DrawATPA(atpa);
  if atpa <> [] then
    bitmap.DrawTPA(atpa[0], SRLColors.BLACK);

  bitmap.DrawCuboidArray(cuboids, SRLColors.YELLOW);
end;

(*
## TRSObject.SaveDebug
```pascal
procedure TRSObject.SaveDebug();
```

Saves a debug image of the TRSObject to Simba\Screenshots\RSObjects

Example:
```pascal
RSObjects.GEBank.SaveDebug(); //Be in ge and with a walker setup there.
```
*)
procedure TRSObject.SaveDebug();
var
  Bitmap: TMufasaBitmap;
  filePath: String;
begin
  Bitmap.FromClient();

  Self.Draw(Bitmap);
  Bitmap.DrawBoxFilled(Chat.GetDisplayNameBox(), False, $00FFFF);

  filePath := GetScreenshotPath('TRSObject');

  Bitmap.SaveToFile(filePath);
  WriteLn('Send ', filePath, ' to Torwent on discord!');
  Bitmap.Debug();

  WriteLn('Position: ', ScriptWalker^.GetMyPos(), ' ZoomLevel: ', MM2MS.ZoomLevel);
  WriteLn('RSObject: ', Self);
  Bitmap.Free();
end;


(*
## TRSObject._UpdateTarget
```pascal
procedure TRSObject._UpdateTarget(sender: PMouse; var x, y: Double; var done: Boolean);
```

Internal helper method of TMouseMovingEventEx type used to update the target position while the mouse is moving.
You should probably not touch this if you don't understand it.
*)
procedure TRSObject._UpdateTarget(sender: PMouse; var x, y: Double; var done: Boolean);
var
  i: Int32;
  atpa: T2DPointArray;
  p, destination: TPoint;
begin
  destination := [Round(x), Round(y)];
  p := sender^.Position();
  if p.DistanceTo(destination) > 5 then
    Exit;
  sender^.OnMovingEx := nil;

  if Self._UpTextCheck(done) then
    Exit;

  done := not Self.Find(atpa);
  if done then
    Exit;

  for i := 0 to High(atpa) do
  begin
    if atpa[i].Contains(destination) then
      Exit;
  end;

  p := atpa[0].RandomValue();
  x := p.X;
  y := p.Y;
end;

(*
## TRSObject._HoverHelper
```pascal
function TRSObject._HoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
```

Internal helper method used to hover a TRSObject target.
You should not use this directly.
*)
function TRSObject._HoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
var
  shouldExit: Boolean;
  attempt: Int32;
  atpa: T2DPointArray;
  tpa: TPointArray;
  angle: Double;
begin
  Result := Self._UpTextCheck(shouldExit);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(atpa) then
    begin
      if attempt < 2 then
        tpa := atpa[0] // 0 for the closest one.
      else if Length(atpa) > (attempt - 2) then
        tpa := atpa[attempt - 2]
      else
        tpa := atpa[Random(0, High(atpa))];

      if trackTarget then
        Mouse.OnMovingEx := @Self._UpdateTarget;
      Mouse.Move(tpa[Random(0, High(tpa))]);

      if not Self.Filter.UpText then
        Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if attempt = (attempts - 1) then
    begin
      angle := Minimap.GetCompassAngle() + Random(-50, 50);
      Minimap.SetCompassAngle(angle, 10);
    end;
  end;
end;

(*
## TRSObject._WalkHoverHelper
```pascal
function TRSObject._WalkHoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
```

Internal helper method used to walk and hover a TRSObject target.
You should not use this directly.

This is responsible for deciding wether we should walk to a TRSObject target or not before attempting to hover it.
*)
function TRSObject._WalkHoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
var
  shouldExit: Boolean;
  attempt: Int32;
  atpa: T2DPointArray;
  tpa: TPointArray;
  angle: Double;
  closestWO: TPoint;
begin
  if not Self.Filter.Walker then
    Exit(Self._HoverHelper(attempts, trackTarget));

  Result := Self._WalkUpTextCheck(shouldExit);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(atpa) then
    begin
      if attempt < 2 then
        tpa := atpa[0]
      else if Length(atpa) > (attempt - 2) then
        tpa := atpa[attempt - 2]
      else
        tpa := atpa.RandomValue();

      if trackTarget then
        Mouse.OnMovingEx := @Self._UpdateTarget;
      Mouse.Move(tpa.RandomValue());

      if not Self.Filter.UpText then
        Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    closestWO := ScriptWalker^.GetClosestPoint(Self.Coordinates);
    if not ScriptWalker^.AtTile(closestWO, 50) then
    begin
      ScriptWalker^.WebWalk(closestWO, 30, 0.15);
      Continue;
    end;

    if attempt = (attempts - 1) then
    begin
      if not ScriptWalker^.AtTile(closestWO, 25) then
      begin
        ScriptWalker^.WebWalk(closestWO, 25, 0.15);
        Continue;
      end;

      angle := Minimap.GetCompassAngle() + Random(-50, 50);
      Minimap.SetCompassAngle(angle, 10);
    end;
  end;
end;

(*
## TRSObject.PreHoverHelper
```pascal
function TRSObject.PreHoverHelper(attempts: Int32): Boolean;
```

Internal helper method used to pre-hover a TRSObject target.
You should not use this directly.
*)
function TRSObject.PreHoverHelper(me: TPoint; attempts: Int32 = 2): Boolean;
var
  attempt: Int32;
  atpa: T2DPointArray;
  tpa: TPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if Self.FindFromPosition(me, atpa) then
    begin
      tpa := atpa[Random(0, High(atpa))];
      ASyncMouse.Move(tpa[Random(0, High(tpa))]);
      Exit(True);
    end;
  end;
end;

(*
## TRSObject.Hover
```pascal
function TRSObject.Hover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
```

Method used to hover a TRSObject target if it's found on the mainscreen.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.Hover(); //Be in GE with a walker setup there.
```
*)
function TRSObject.Hover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Filter.Walker and not ScriptWalker^.MakePointVisible(Self.Coordinates) then
    Exit;

  Result := Self._HoverHelper(attempts, trackTarget);
end;

(*
## TRSObject.WalkHover
```pascal
function TRSObject.WalkHover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
```

Method used to walk and hover a TRSObject target if it's found on the mainscreen after walking.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
//Be in varrock with a varrock map loaded.
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.WalkHover();
```
*)
function TRSObject.WalkHover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
var
  p: TPoint;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if not Self.Filter.Walker then
    Exit;

  if Self.Filter.UpText then
    TRSWalkerObject.CurrentUpText := Self.UpText;

  p := ScriptWalker^.GetClosestPoint(Self.Coordinates);
  if not ScriptWalker^.MakePointVisible(p) and
     not ScriptWalker^.WebWalk(p, 30, 0.15) then
      Exit;

  Result := Self._WalkHoverHelper(attempts, trackTarget);
end;


(*
## TRSObject.Click
```pascal
function TRSObject.Click(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
```

Method used to click a TRSObject target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded.
WriteLn RSObjects.GEBank.Click();
```
*)
function TRSObject.Click(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(attempts) and Self._ClickHelper(leftClick);
end;


(*
## TRSObject.SelectOption
```pascal
function TRSObject.SelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
```

Method used to select an option on a TRSObject target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded.
WriteLn RSObjects.GEBank.SelectOption(['Collect']);
```
*)
function TRSObject.SelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := action;
  Self.CurrentActionUpText := action;
  Result := Self.Hover(attempts) and Self._SelectHelper(action);
  Self.ActionUpText := [];
  Self.CurrentActionUpText := [];
end;


(*
## TRSObject.WalkClick
```pascal
function TRSObject.WalkClick(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
```

Method used to walk and click a TRSObject target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded, preferably far away so it has to walk.
WriteLn RSObjects.GEBank.WalkClick();
```
*)
function TRSObject.WalkClick(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSObject.WalkSelectOption
```pascal
function TRSObject.WalkSelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
```

Method used to walk and select an option on a TRSObject target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded, preferably far away so it has to walk.
WriteLn RSObjects.GEBank.WalkSelectOption(['Collect']);
```
*)
function TRSObject.WalkSelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := action;
  Self.CurrentActionUpText := action;
  Result := Self.WalkHover(attempts) and Self._SelectHelper(action);
  Self.ActionUpText := [];
  Self.CurrentActionUpText := [];
end;

function PRSObjectArray.GetClosestEx(value: TPoint): PRSObject;
var
  i: Int32;
  closest: Double = $FFFFFF;
  current: Double;
begin
  for i := High(Self) downto 0 do
  begin
    if Self[i]^.Coordinates = [] then
    begin
      Delete(Self, i, 1);
      Continue;
    end;

    current := Self[i]^.Coordinates.NearestPoint(value).DistanceTo(value);
    if current < closest then
    begin
      closest := current;
      Result := Self[i];
    end;
  end;
end;

function PRSObjectArray.GetClosest(): PRSObject;
begin
  if (Self = []) or (ScriptWalker = nil) then
    Exit;

  Result := Self.GetClosestEx(ScriptWalker^.GetMyPos());
end;


type
(*
## type TRSMMDot

TRSMMDot are a type of TRSWalkerObject.
This are meant to be TRSWalkerObjects that have a minimap dot so TRSMMDot.Filter.MinimapDot is True by default and shouldn't be changed.
This also have a **DotType** variable for the type of ERSMinimapDot they have (PLAYER, NPC, ITEM) and a **DotFilter** which is used to
filter mmdots in/out of circles and/or polygons so we only focus on the TRSMMDots we want.
*)
  TRSMMDot = record(TRSWalkerObject)
    ClosestDot: TPoint;
    DotType: ERSMinimapDot;
    DotFilter: TRSDotFilterArray;
  end;

(*
## TRSMMDot.Setup
```pascal
procedure TRSMMDot.SetupEx(radius: Int32; shape: Vector3; coordinates: TPointArray); overload;
procedure TRSMMDot.Setup(radius: Int32; size, height: Double; coordinates: TPointArray); overload;
procedure TRSMMDot.Setup(radius: Int32; height: Double; coordinates: TPointArray); overload;
```

All this extend the basic `TRSWalkerObject.Setup(coordinates: TPointArray)` specifically for TRSMMDots.
For TRSMMDots this are the methods that should be used for setting them up initially.

In TRSMMDot.Setup(radius: Int32; shape: Vector3; coordinates: TPointArray),
**radius** is used to create a simple TRSDotFilterArray of that radius with **cordinates** and their center point.
**shape** should be a vector3 of the target shape in number of tiles:

- shape.X: Number of tiles of the target from west to east.

- shape.Y: Number of tiles of the target from north to south.

- shape.Z: Target height, this value has to be guessed, I recommend you try several values and debug it until it looks good to you. As some examples, player and npcs height is around 7, bank chests 4, yew/magic trees 14/16.


For NPCs that can move and are 1x2 tiles or any uneven number of tiles,
I recommend you just set **shape.X** and **shape.Y** to the largest one. So a cow I would recommend making the shape 2x2.


The other methods all call this first one with certain default values:

- Size makes shape.X and shape.Y equal to size.

- If size is omited, shape.X and shape.Y are set to 1.
*)
procedure TRSMMDot.SetupCoordinates(radii: TIntegerArray; coordinates: TPointArray); overload;
var
  i, j, hi: Int32;
begin
  Self.Filter.Skip := (ScriptWalker = nil) or (radii = []) or (coordinates = []);

  if Self.Filter.Skip then
    Exit;

  hi := radii[High(radii)];
  for i := High(radii) to High(coordinates) do
    radii += hi;

  for i := 0 to High(coordinates) do
  begin
    for j := 0 to High(ScriptWalker^.Regions) do
    begin
      if ScriptWalker^.Regions[j].Contains(coordinates[i]) then
      begin
        Self.Coordinates += coordinates[i];
        Self.DotFilter.Setup([coordinates[i].X, coordinates[i].Y, radii[i]], True);
      end;
    end;
  end;

  Self.Filter.Skip := Self.Coordinates = [];
  if Self.Filter.Skip then
    Exit;

  Self.Filter.Walker := True;
  SetLength(Self.ShapeArray, Length(Self.Coordinates));
end;

procedure TRSMMDot.SetupEx(radius: Int32; shape: Vector3; coordinates: TPointArray); overload;
var
  p: TPoint;
begin
  Self.SetupCoordinates(coordinates);

  if Self.Filter.Skip then
    Exit;

  //Self.Coordinates is better than coordinates here because they are already filtered.
  for p in Self.Coordinates do
    Self.DotFilter.Setup([p.X, p.Y, radius], True);

  Self.ShapeArray.SetShape(shape);
end;

procedure TRSMMDot.Setup(radius: Int32; size, height: Double; coordinates: TPointArray); overload;
begin
  Self.SetupEx(radius, [size, size, height], coordinates);
end;

procedure TRSMMDot.Setup(radius: Int32; height: Double; coordinates: TPointArray); overload;
begin
  Self.Setup(radius, 1, height, coordinates);
end;

procedure TRSMMDot.SetupEx(radii: TIntegerArray; shape: Vector3; coordinates: TPointArray); overload;
begin
  Self.SetupCoordinates(radii, coordinates);

  if not Self.Filter.Skip then
    Self.ShapeArray.SetShape(shape);
end;

procedure TRSMMDot.Setup(radii: TIntegerArray; size, height: Double; coordinates: TPointArray); overload;
begin
  Self.SetupEx(radii, [size, size, height], coordinates);
end;

procedure TRSMMDot.Setup(radii: TIntegerArray; height: Double; coordinates: TPointArray); overload;
begin
  Self.Setup(radii, 1, height, coordinates);
end;

(*
## TRSMMDot._GetCuboids
```pascal
function TRSMMDot._GetWMMCuboids(out mmTPA, dots: TPointArray; out dotFilters: TRSDotFilterArray): TCuboidExArray;
function TRSMMDot._GetMMCuboids(out dots: TPointArray): TCuboidExArray;
```
Internal helper {ref}`TRSMMDot` method used for debugging.
You probably dont need to use this directly.
You can see what this does in action by calling `Debug(TRSMMDot)`.
*)
function TRSMMDot._GetWMMCuboids(out mmTPA, dots: TPointArray; out dotFilters: TRSDotFilterArray): TCuboidExArray;
var
  me: TPoint;
  angle: Double;
begin
  me := ScriptWalker^.GetMyPos();
  angle := Minimap.GetCompassAngle(False);

  mmTPA := ScriptWalker^.WorldToMM(me, Self.Coordinates, angle);

  dotFilters := ScriptWalker^.WorldToMM(me, Self.DotFilter, angle);
  dots := Minimap.GetFilteredDotArray(Self.DotType, dotFilters);

  Result := Minimap.GetCuboidArrayMS(dots, Self.ShapeArray, [2, 2], angle);
end;

function TRSMMDot._GetMMCuboids(out dots: TPointArray): TCuboidExArray;
var
  angle: Double;
  offset: TPoint;
begin
  angle := Minimap.GetCompassAngle(False);

  dots := Minimap.Getdots(Self.DotType);
  offset := [2,2];

  Result := Minimap.GetCuboidArrayMS(dots, Self.ShapeArray, [2, 2], angle);
end;


(*
## TRSMMDot.GetCuboidArray
```pascal
function TRSMMDot.GetCuboidArrayEx(out mmTPA, dots: TPointArray; out dotFilters: TRSDotFilterArray; out floorTiles: TRectArray; out roofTiles: TRectArray): TCuboidArray; overload;
function TRSMMDot.GetCuboidArray(): TCuboidArray; override;
```

Internal TRSMMDot method responsible for returning a TCuboidArray of our target on the 3D world (on mainscreen and outside of it).
This uses the previous 2 helper methods to do this.
You will probably never need to use this directly.
You can visually see this in action by using the `Debug()` methods, this is responsible for the white lines surounding the targets.
*)
function TRSMMDot.GetCuboidArrayEx(out mmTPA, dots: TPointArray; out dotFilters: TRSDotFilterArray): TCuboidExArray; overload;
begin
  if Self.Filter.Walker and Self.Filter.MinimapDot then
    Exit(Self._GetWMMCuboids(mmTPA, dots, dotFilters));

  if Self.Filter.Walker then
    Exit(Self.GetCuboidArray());

  if Self.Filter.MinimapDot then
    Exit(Self._GetMMCuboids(dots));
end;

function TRSMMDot.GetCuboidArray(me: TPoint = []): TCuboidExArray; override;
var
  angle: Double;
  dots: TPointArray;
begin
  if Self.Filter.Walker and Self.Filter.MinimapDot then
  begin
    angle := Minimap.GetCompassAngle(False);
    dots := Minimap.GetFilteredDotArray(Self.DotType, ScriptWalker^.WorldToMM(Self.DotFilter, angle));
    if dots = [] then
      Exit;

    dots := dots.SortFrom(Minimap.Center());

    Exit(Minimap.GetCuboidArrayMS(dots, Self.ShapeArray, [2, 2], angle));
  end;

  if Self.Filter.Walker then
  begin
    Result := inherited;
    Exit;
  end;

  if Self.Filter.MinimapDot then
  begin
    dots := Minimap.GetDots(Self.DotType);
    if dots = [] then
      Exit;

    dots := dots.SortFrom(Minimap.Center());

    if Self.ShapeArray = [] then
      Self.ShapeArray.SetShape([1, 1, 1]);

    Exit(Minimap.GetCuboidArrayMS(dots, Self.ShapeArray, [2, 2]));
  end;
end;

(*
## TRSMMDot.FindEx
```pascal
function TRSMMDot.FindEx(out mmPoints, dots: TPointArray; out DotFilters: TRSDotFilterArray; out floorTiles: TRectArray; out roofTiles: TRectArray; out cuboidArray: TCuboidArray; out atpa: T2DPointArray): Boolean;
```

TRSMMDot methods used to find a TRSMMDot. If found returns true, if not returns false.
This "extended" method in particular is only meant for debugging and should be avoided outside of development/debugging.
This is what is used when you call `Debug(TRSMMDot)`.
*)
function TRSMMDot.FindEx(out mmPoints, dots: TPointArray; out dotFilters: TRSDotFilterArray; out cuboids: TCuboidExArray; out atpa: T2DPointArray): Boolean;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    cuboids := Self.GetCuboidArrayEx(mmPoints, dots, dotFilters);
    if cuboids = [] then
      Exit;

    atpa := Self.FindOnMainScreen(cuboids);
  end
  else if Self.Filter.Finder then
    atpa := MainScreen.FindObject(Self.Finder).SortFrom(MainScreen.GetPlayerBox().Center());

  if Result := (atpa <> []) then
    if ScriptWalker <> nil then
      Self.ClosestDot := ScriptWalker^.MSToWorld(atpa.First().Mean()); //not the best way since we are reversing operations but will do for now.
end;

(*
## TRSMMDot.Find
```pascal
function TRSMMDot.Find(out atpa: T2DPointArray): Boolean; overload;
function TRSMMDot.Find(): Boolean; overload;
```

TRSMMDot methods used to find a TRSMMDot. If found returns true, if not returns false.

Example:
```pascal
WriteLn RSNPCs.LumbridgeCook.Find(atpa); //Be in lumbridge castle and with a walker setup there.
Debug(atpa);
```
*)
function TRSMMDot.Find(out atpa: T2DPointArray): Boolean; overload;
var
  cuboidArray: TCuboidExArray;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    cuboidArray := Self.GetCuboidArray();

    if cuboidArray = [] then
      Exit;

    atpa := Self.FindOnMainScreen(cuboidArray);
  end

  else if Self.Filter.Finder then
    atpa := MainScreen.FindObject(Self.Finder).SortFrom(MainScreen.GetPlayerBox().Center());

  Result := atpa <> [];
  if Result and (ScriptWalker <> nil) then
      Self.ClosestDot := ScriptWalker^.MSToWorld(ATPA[0].Mean());
end;

function TRSMMDot.IsVisible(): Boolean; overload;
var
  cuboidArray: TCuboidExArray;
begin
  MM2MS.SetupZoom();

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    cuboidArray := Self.GetCuboidArray();

    if cuboidArray = [] then
      Exit;

    Exit(Self.OnMainScreen(cuboidArray));
  end;

  if Self.Filter.Finder then
    Result := MainScreen.FindObject(Self.Finder) <> [];
end;

(*
## TRSMMDot._GetBaseRecord
```pascal
function TRSMMDot._GetBaseRecord(): TRSMMDot;
```

Internal method used for casting custom TRSMMDots back to the base record.
*)
function TRSMMDot._GetBaseRecord(): TRSMMDot;
begin
  Result := Self;
end;

(*
## TRSMMDot.Draw
```pascal
procedure TRSMMDot.Draw(out bitmap: TMufasaBitmap);
```

Internal method used to draw found TRSMMDot in a TMufasaBitmap.

Example:
```pascal
Bitmap.FromClient()
RSNPCs.LumbridgeCook.Draw(Bitmap); //Be in Lumbridge castle and with a walker setup there.
Bitmap.Debug();
Bitmap.Free();
```
*)
procedure TRSMMDot.Draw(out Bitmap: TMufasaBitmap);
var
  mmPoints, dots: TPointArray;
  dotFilters: TRSDotFilterArray;
  cuboids: TCuboidExArray;
  atpa: T2DPointArray;
  i: Int32;
begin
  Self.FindEx(mmPoints, dots, dotFilters, cuboids, atpa);

  //Minimap drawing
  for i := 0 to High(mmPoints) do
    bitmap.DrawCrosshairs(mmPoints[i], 4, SRLColors.BLUE);

  for i := 0 to High(dotFilters) do
  begin
    if dotFilters[i].HasTimer and dotFilters[i].Timer.IsFinished() then
      Continue;

    if dotFilters[i].TPA <> [] then
    begin
      if dotFilters[i].Inside then
        bitmap.DrawTPA(dotFilters[i].TPA.Connect(), SRLColors.LIME)
      else
        bitmap.DrawTPA(dotFilters[i].TPA.Connect(), SRLColors.RED);
    end;

    if dotFilters[i].Circle <> [] then
    begin
      if dotFilters[i].Inside then
        bitmap.DrawCircle(dotFilters[i].Circle.Mean(), dotFilters[i].Circle.Radius, SRLColors.LIME)
      else
        bitmap.DrawCircle(dotFilters[i].Circle.Mean(), dotFilters[i].Circle.Radius, SRLColors.RED);
    end;
  end;

  bitmap.DrawATPA(atpa);
  if atpa <> [] then
    bitmap.DrawTPA(atpa[0], SRLColors.BLACK);
  bitmap.DrawCuboidArray(cuboids, SRLColors.YELLOW);
end;


(*
## TRSMMDot.SaveDebug
```pascal
procedure TRSMMDot.SaveDebug();
```

Saves a debug image of the TRSMMDot to Simba\Screenshots\RSMMDots

Example:
```pascal
RSNPCs.LumbridgeCook.SaveDebug(); //Be in Lumbridge castle and with a walker setup there.
```
*)
procedure TRSMMDot.SaveDebug();
var
  Bitmap: TMufasaBitmap;
  filePath: String;
begin
  Bitmap.FromClient();

  Self.Draw(Bitmap);
  Bitmap.DrawBoxFilled(Chat.GetDisplayNameBox(), False, $00FFFF);

  filePath := GetScreenshotPath('TRSMMDot');
  Bitmap.SaveToFile(filePath);
  WriteLn('Send ', filePath, ' to Torwent on discord!');
  Bitmap.Debug();

  WriteLn('Position: ', ScriptWalker^.GetMyPos(), ' ZoomLevel: ', MM2MS.ZoomLevel);
  WriteLn('RSObject: ', Self);
  Bitmap.Free();
end;


(*
## TRSMMDot._UpdateTarget
```pascal
procedure TRSMMDot._UpdateTarget(sender: PMouse; var x, y: Double; var done: Boolean);
```

Internal helper method of TMouseMovingEventEx type used to update the target position while the mouse is moving.
You should probably not touch this if you don't understand it.
*)
procedure TRSMMDot._UpdateTarget(sender: PMouse; var x, y: Double; var done: Boolean);
var
  i: Int32;
  atpa: T2DPointArray;
  p, destination: TPoint;
begin
  destination := [Round(x), Round(y)];
  p := sender^.Position();
  if p.DistanceTo(destination) > 5 then
    Exit;
  sender^.OnMovingEx := nil;

  if Self._UpTextCheck(done) then
    Exit;

  done := not Self.Find(atpa);
  if done then
    Exit;

  for i := 0 to High(atpa) do
  begin
    if atpa[i].Contains(destination) then
      Exit;
  end;

  p := atpa[0].RandomValue();
  x := p.X;
  y := p.Y;
end;

(*
## TRSMMDot._HoverHelper
```pascal
function TRSMMDot._HoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
```

Internal helper method used to hover a TRSMMDot target.
You should not use this directly.
*)
function TRSMMDot._HoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
var
  shouldExit: Boolean;
  attempt: Int32;
  atpa: T2DPointArray;
  tpa: TPointArray;
  angle: Double;
begin
  if Self.Filter.MinimapDot and (Minimap.GetDots(Self.DotType) = []) then
    Exit;

  Result := Self._UpTextCheck(shouldExit);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(atpa) then
    begin
      if attempt < 2 then
        tpa := atpa[0]
      else if Length(atpa) > (attempt - 2) then
        tpa := atpa[attempt - 2]
      else
        tpa := atpa.RandomValue();

      if trackTarget then
        Mouse.OnMovingEx := @Self._UpdateTarget;

      if Self.DotType = ERSMinimapDot.ITEM then
        Mouse.Move(tpa.Mean())
      else
        Mouse.Move(tpa.RandomValue());

      if not Self.Filter.UpText then
        Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if attempt = (attempts - 1) then
    begin
      angle := Minimap.GetCompassAngle() + Random(-50, 50);
      Minimap.SetCompassAngle(angle, 10);
    end;
  end;
end;

(*
## TRSMMDot._WalkHoverHelper
```pascal
function TRSMMDot._WalkHoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
```

Internal helper method used to walk and hover a TRSMMDot target.
You should not use this directly.

This is responsible for deciding wether we should walk to a TRSMMDot target or not before attempting to hover it.
*)
function TRSMMDot._WalkHoverHelper(attempts: Int32; trackTarget: Boolean): Boolean;
var
  shouldExit: Boolean;
  attempt: Int32;
  atpa: T2DPointArray;
  tpa: TPointArray;
  angle: Double;
  closestWO: TPoint;
begin
  if not Self.Filter.Walker then
    Exit(Self._HoverHelper(attempts, trackTarget));

  Result := Self._WalkUpTextCheck(shouldExit);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(atpa) then
    begin
      if attempt < 2 then
        tpa := atpa[0]
      else if Length(atpa) > (attempt - 2) then
        tpa := atpa[attempt - 2]
      else
        tpa := atpa.RandomValue();

      if trackTarget then
        Mouse.OnMovingEx := @Self._UpdateTarget;

      if Self.DotType = ERSMinimapDot.ITEM then
        Mouse.Move(tpa.Mean())
      else
        Mouse.Move(tpa.RandomValue());

      if not Self.Filter.UpText then
        Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    if not Self.DotFilter.DotValid(ScriptWalker^.GetMyPos()) then
    begin
      closestWO := ScriptWalker^.GetClosestPoint(Self.Coordinates);
      if not ScriptWalker^.AtTile(closestWO, 50) then
      begin
        ScriptWalker^.WebWalk(closestWO, 30, 0.15);
        Continue;
      end;
    end;

    if attempt = (attempts - 1) then
    begin
      angle := Minimap.GetCompassAngle() + Random(-50, 50);
      Minimap.SetCompassAngle(angle, 10);
    end;
  end;
end;


(*
## TRSMMDot.Hover
```pascal
function TRSMMDot.Hover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
```

Method used to hover a TRSMMDot target if it's found on the mainscreen.
It can update the target position as the mouse moves with **trackTarget**.
For NPCs that move, this is highly recommended.

Example:
```pascal
//Be in Lumbridge castle
RSW.WebWalk(WaspWeb.LOCATION_LUMBRIDGE);
RSNPCs.LumbridgeCook.Hover();
```
*)
function TRSMMDot.Hover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean; overload;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Filter.UpText then
    TRSWalkerObject.CurrentUpText := Self.UpText;

  if Self.Filter.Walker and not ScriptWalker^.MakePointVisible(Self.Coordinates) then
    Exit;

  Result := Self._HoverHelper(attempts, trackTarget);
end;

(*
## TRSMMDot.WalkHover
```pascal
function TRSMMDot.WalkHover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
```

Method used to walk and hover a TRSMMDot target if it's found on the mainscreen after walking.
It can update the target position as the mouse moves with **trackTarget**.
For NPCs that move, this is highly recommended.

Example:
```pascal
//Be in Lumbridge castle
RSW.WebWalk(WaspWeb.LOCATION_LUMBRIDGE);
RSNPCs.LumbridgeCook.WalkHover();
```
*)
function TRSMMDot.WalkHover(attempts: Int32 = 2; trackTarget: Boolean = TRACK_TARGET): Boolean;
var
  closestWO: TPoint;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if not Self.Filter.Walker then
    Exit;

  if Self.Filter.UpText then
    TRSWalkerObject.CurrentUpText := Self.UpText;

  if not Self.DotFilter.DotValid(ScriptWalker^.GetMyPos()) then
  begin
    closestWO := ScriptWalker^.GetClosestPoint(Self.Coordinates);

    if not ScriptWalker^.MakePointVisible(closestWO) and
       not ScriptWalker^.WebWalk(closestWO, 30, 0.15) then
        Exit;
  end;

  Result := Self._WalkHoverHelper(attempts, trackTarget);
end;


(*
## TRSMMDot.Click
```pascal
function TRSMMDot.Click(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
```

Method used to click a TRSMMDot target if it's found on the mainscreen.

Example:
```pascal
//Be in Lumbridge castle with a walker map of it loaded.
WriteLn RSNPCs.LumbridgeCook.Click();
```
*)
function TRSMMDot.Click(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSMMDot.SelectOption
```pascal
function TRSMMDot.SelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
```

Method used to select an option on a TRSMMDot target if it's found on the mainscreen.

Example:
```pascal
//Be in Lumbridge castle with a walker map of it loaded.
WriteLn RSNPCs.LumbridgeCook.SelectOption(['Examine']);
```
*)
function TRSMMDot.SelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := action;
  Self.CurrentActionUpText := action;
  Result := Self.Hover(attempts) and Self._SelectHelper(action);
  Self.ActionUpText := [];
  Self.CurrentActionUpText := [];
end;


(*
## TRSMMDot.WalkClick
```pascal
function TRSMMDot.WalkClick(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
```

Method used to walk and click a TRSMMDot target if it's found on the mainscreen.

Example:
```pascal
//Be in Lumbridge castle with a walker map of it loaded.
WriteLn RSNPCs.LumbridgeCook.WalkClick();
```
*)
function TRSMMDot.WalkClick(leftClick: Boolean = True; attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSMMDot.WalkSelectOption
```pascal
function TRSMMDot.WalkSelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
```

Method used to walk and select an option on a TRSMMDot target if it's found on the mainscreen.

Example:
```pascal
//Be in Lumbridge castle with a walker map of it loaded.
WriteLn RSNPCs.LumbridgeCook.WalkSelectOption(['Examine']);
```
*)
function TRSMMDot.WalkSelectOption(action: TStringArray; attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := action;
  Self.CurrentActionUpText := action;
  Result := Self.WalkHover(attempts) and Self._SelectHelper(action);
  Self.ActionUpText := [];
  Self.CurrentActionUpText := [];
end;

type
(*
## type TRSNPC

TRSNPC are a type of TRSMMDot and TRSWalkerObject.
This are meant to be TRSMMDot that have a yellow minimap dot so TRSNPC.Filter.MinimapDot is True by default and shouldn't be changed.
*)
  TRSNPC = type TRSMMDot;
  TRSNPCArray = array of TRSNPC;
  PRSNPC = ^TRSNPC;
  PRSNPCArray = array of PRSNPC;

(*
## type TRSGroundItem

TRSGroundItem are a type of TRSMMDot and TRSWalkerObject.
This are meant to be TRSMMDot that have a red minimap dot so TRSGroundItem.Filter.MinimapDot is True by default and shouldn't be changed.
*)
  TRSGroundItem = type TRSMMDot;
  TRSGroundItemArray = array of TRSGroundItem;
  PRSGroundItem = ^TRSGroundItem;
  PRSGroundItemArray = array of PRSGroundItem;

(*
## type TRSPlayer

TRSPlayer are a type of TRSMMDot and TRSWalkerObject.
This are meant to be TRSMMDot that have a white minimap dot so TRSPlayer.Filter.MinimapDot is True by default and shouldn't be changed.
*)
  TRSPlayer = type TRSMMDot;
  TRSPlayerArray = array of TRSPlayer;

(*
## TRSMMDot.SetupUpText
```pascal
procedure TRSNPC.SetupUpText(upText: TStringArray); override;
procedure TRSGroundItem.SetupUpText(upText: TStringArray); override;
procedure TRSPlayer.SetupUpText(upText: TStringArray); override;
```
Setup method that extends TRSWalkerObject.SetupUpText(upText: TStringArray);
These are the methods that should be used to setup TRSNPCs, TRSGroundItems and TRSPlayers as it ensures that the
TRSNPC.DotType is correctly set.
*)
procedure TRSNPC.Setup(upText: TStringArray); override; //deprecated 'Use TRSNPC.SetupUpText() instead.';
begin
  WriteLn('TRSNPC.Setup() is deprecated use TRSNPC.SetupUpText() instead.');
  if Self.Filter.Skip then
    Exit;

  Self._Setup();
  Self.Filter.MinimapDot := True;

  Self.UpText := upText;

  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;
  Self.DotType := ERSMinimapDot.NPC;
end;

procedure TRSNPC.SetupUpText(upText: TStringArray); override;
begin
  if Self.Filter.Skip then
    Exit;

  Self._Setup();
  Self.Filter.MinimapDot := True;

  Self.UpText := upText;

  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;
  Self.DotType := ERSMinimapDot.NPC;
end;

procedure TRSGroundItem.SetupUpText(upText: TStringArray); override;
begin
  if Self.Filter.Skip then
    Exit;

  Self._Setup();
  Self.Filter.MinimapDot := True;

  Self.UpText := upText;

  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;
  Self.DotType := ERSMinimapDot.ITEM;
end;

procedure TRSPlayer.SetupUpText(upText: TStringArray); override;
begin
  if Self.Filter.Skip then
    Exit;

  Self._Setup();
  Self.Filter.MinimapDot := True;

  Self.UpText := upText;

  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;
  Self.DotType := ERSMinimapDot.PLAYER;
end;


function PRSNPCArray.GetClosestEx(value: TPoint): PRSNPC;
var
  i: Int32;
  closest, current: Double;
begin
  if Self = [] then
    Exit;

  closest := $FFFFFF;

  for i := High(Self) downto 0 do
  begin
    if Self[i]^.Coordinates = [] then
    begin
      Delete(Self, i, 1);
      Continue;
    end;

    current := Self[i]^.Coordinates.NearestPoint(value).DistanceTo(value);
    if current < closest then
    begin
      closest := current;
      Result := Self[i];
    end;
  end;
end;

function PRSNPCArray.GetClosest(): PRSNPC;
begin
  if (Self = []) or (ScriptWalker = nil) then
    Exit;

  Result := Self.GetClosestEx(ScriptWalker^.GetMyPos());
end;


function PRSGroundItemArray.GetClosestEx(value: TPoint): PRSGroundItem;
var
  i: Int32;
  closest, current: Double;
begin
  if Self = [] then
    Exit;

  closest := $FFFFFF;

  for i := High(Self) downto 0 do
  begin
    if Self[i]^.Coordinates = [] then
    begin
      Delete(Self, i, 1);
      Continue;
    end;

    current := Self[i]^.Coordinates.NearestPoint(value).DistanceTo(value);
    if current < closest then
    begin
      closest := current;
      Result := Self[i];
    end;
  end;
end;

function PRSGroundItemArray.GetClosest(): PRSGroundItem;
begin
  if (Self = []) or (ScriptWalker = nil) then
    Exit;

  Result := Self.GetClosestEx(ScriptWalker^.GetMyPos());
end;


(*
## Debug
```pascal
procedure Debug(rsobject: TRSObject); overload;
procedure Debug(mmdot: TRSMMDot); overload;
```
Methods used to debug TRSObjects and TRSMMDots.

Example:
```pascal
Debug(RSObjects.GEBank); //Run in ge with a walker map setup there.

Debug(RSNPCs.LumbridgeCook); //Run in Lumbridge castle with a walker map setup there.
```
*)
procedure Debug(rsobject: TRSObject); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  rsobject.Draw(bitmap);
  bitmap.Debug();
  bitmap.Free();
end;

procedure Debug(mmdot: TRSMMDot); overload;
var
  bitmap: TMufasaBitmap;
begin
  bitmap.FromClient();
  mmDot.Draw(bitmap);
  bitmap.Debug();
  bitmap.Free();
end;

type
  TRSWalkerObjects = record
    Banks, DepositBoxes: PWalkerObjectArray;
  end;

var
  WalkerObjects: TRSWalkerObjects;
  DebugObjectArray: TRSObjectArray;
  DebugMMDotArray: array of TRSMMDot;

function TRSBank.Hover(rsObject: TRSObject): Boolean; overload;
begin
  if MainScreen.HasInterface() then
    Exit;
  Result := rsObject.Hover();
end;

function TRSBank.Open(rsObject: TRSObject): Boolean; overload;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  Result := rsObject.Click() or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen() or BankPin.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;

function TRSBank.WalkHover(rsObject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
    Exit;

  Result := rsObject.WalkHover();
end;

function TRSBank.WalkOpen(rsObject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  Result := rsObject.WalkClick() or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;


function TRSBank.Hover(rsNPC: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
    Exit;
  Result := rsNPC.Hover();
end;

function TRSBank.Open(rsNPC: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  Result := rsNPC.SelectOption(['Bank B', 'Bank E']) or (MainScreen.IsUpText('Bank') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen() or BankPin.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;

function TRSBank.WalkHover(rsNPC: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
    Exit;

  Result := rsNPC.WalkHover();
end;

function TRSBank.WalkOpen(rsNPC: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() or BankPin.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  Result := rsNPC.SelectOption(['Bank B', 'Bank E']) or (MainScreen.IsUpText('Bank') and ChooseOption.Select(['Bank B', 'Bank E']));

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
end;


function TRSBank.Hover(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.Banks.GetClosest();

  if walkerObject^.Filter.MinimapDot then
    Exit(Self.Hover(PRSNPC(walkerObject)^));

  Result := Bank.Hover(PRSObject(walkerObject)^);
end;

function TRSBank.Open(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.Banks.GetClosest();

  if walkerObject^.Filter.MinimapDot then
    Exit(Bank.Open(PRSNPC(walkerObject)^));

  Result := Bank.Open(PRSObject(walkerObject)^);
end;

function TRSBank.WalkHover(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.Banks.GetClosest();

  if walkerObject^.Filter.MinimapDot then
    Exit(Bank.WalkHover(PRSNPC(walkerObject)^));

  Result := Bank.WalkHover(PRSObject(walkerObject)^);
end;

function TRSBank.WalkOpen(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.Banks.GetClosest();

  if walkerObject^.Filter.MinimapDot then
    Exit(Bank.WalkOpen(PRSNPC(walkerObject)^));

  Result := Bank.WalkOpen(PRSObject(walkerObject)^);
end;


function TRSDepositBox.Hover(rsobject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
    Exit;

  Result := rsobject.Hover();
end;

function TRSDepositBox.Open(rsobject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  if rsobject.Click() or ChooseOption.Select(['Deposit B', 'Bank D']) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

function TRSDepositBox.WalkHover(rsobject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
    Exit;

  Result := rsobject.WalkHover();
end;

function TRSDepositBox.WalkOpen(rsobject: TRSObject): Boolean;
begin
  if MainScreen.HasInterface() then
  begin
    if Self.IsOpen() then
      Exit(True);
    MainScreen.CloseInterface();
  end;

  if rsobject.WalkClick() or ChooseOption.Select(['Deposit B', 'Bank D']) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;


function TRSDepositBox.Hover(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.DepositBoxes.GetClosest();

  Result := Self.Hover(PRSObject(walkerObject)^);
end;

function TRSDepositBox.Open(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.DepositBoxes.GetClosest();

  Result := Self.Open(PRSObject(walkerObject)^);
end;

function TRSDepositBox.WalkHover(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.DepositBoxes.GetClosest();

  Result := Self.WalkHover(PRSObject(walkerObject)^);
end;

function TRSDepositBox.WalkOpen(walkerObject: PRSWalkerObject = nil): Boolean; overload;
begin
  if walkerObject = nil then
    walkerObject := WalkerObjects.Banks.GetClosest();

  Result := Self.WalkOpen(PRSObject(walkerObject)^);
end;


procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
var
  DebugObject: TRSObject;
  DebugDot: TRSMMDot;
begin
  inherited;

  for DebugObject in DebugObjectArray do
    DebugObject.Draw(Bitmap);

  for DebugDot in DebugMMDotArray do
    DebugDot.Draw(Bitmap);
end;
